<!DOCTYPE html>
<html lang="zh-CN">
<title>函数式编程 101 | Hugo 主题 MemE</title>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.67.1" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="http://localhost:1313/css/index.css">
<link rel="stylesheet" href="http://localhost:1313/css/classes.css">
<link rel="canonical" href="http://localhost:1313/post/functional-programming-concepts/">
<link rel="alternate" type="application/rss+xml" href="" title="Hugo 主题 MemE">

<body>

<header class="icons">
  
    <a href="http://localhost:1313/">Hugo 主题 MemE</a>
  
  
    <nav>
    
      <a href="/posts/" >
        
          文章
        
      </a>
    
      <a href="/categories/" >
        
          分类
        
      </a>
    
      <a href="/tags/" >
        
          标签
        
      </a>
    
      <a href="/about/" >
        
          关于
        
      </a>
    
      <a href="" >
        
          
        
      </a>
    
      <a href="" >
        
          
        
      </a>
    
    </nav>
  
  
</header>

<article>
  <header>
    <h1>函数式编程 101</h1>
    <time datetime="2016-01-12T21:07:54&#43;08:00">January 12, 2016</time>
  </header>
  <p>函数式编程这几年变得越来越流行起来，越来越多的语音融入了函数式编程的语法，就连更新缓慢如Java也不例外，在Java8中引入了函数式编程的语法。JVM平台的后起之秀Scala，Groovy更是出生之初就有内置了对函数式编程的支持。作为最经常被拿来与Java做比较的C#，更是抢先一步在.NET 3.5版本时就有了对函数式编程的支持。后来.NET平台上更是直接引入了函数式编程语言F#。</p>
<p>函数式编程的兴起并非没有原因。</p>
<ul>
<li><strong>函数式编程语言一般极具表现力</strong>. 相比主流的面向对象语言能以极少的代码完成相同的工作。与代码量的减少相对应的就是维护成本的降低。</li>
<li>相对于命令式编程，<strong>函数式编程语言都是采用声明式编程的方式</strong>，能在更高的抽象级别上编程，代码更易于理解。</li>
<li>**纯函数是没有副作用的，既不会修改全局状态，也不会修改传入的参数。**在进行多线程编程时，就从根本上避免死锁，活锁或者是线程饥饿的问题。</li>
</ul>
<h2 id="函数式编程语言的特征">函数式编程语言的特征</h2>
<h3 id="高阶函数">高阶函数</h3>
<p>在函数式编程语言中，函数终于成为一等公民，可以跟变量一样作为参数传递，同时也可以作为函数返回值返回。这个功能带来的直接好处就是当我们需要传递<strong>行为</strong>的时候，不必在跟之前一样为了传递行为而引入一个对象。例如在Java 8之前，当我们想排序一个List时：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">	<span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">values</span> <span class="o">=</span> <span class="n">newArrayList</span><span class="o">(</span><span class="n">11</span><span class="o">,</span> <span class="n">2</span><span class="o">,</span> <span class="n">43</span><span class="o">,</span> <span class="n">14</span><span class="o">,</span> <span class="n">5</span><span class="o">,</span> <span class="n">76</span><span class="o">,</span> <span class="n">6</span><span class="o">);</span>
	<span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">values</span><span class="o">,</span> <span class="k">new</span> <span class="n">Comparator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
	    <span class="nd">@Override</span>
	    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="n">Integer</span> <span class="n">one</span><span class="o">,</span> <span class="n">Integer</span> <span class="n">other</span><span class="o">)</span> <span class="o">{</span>
	        <span class="k">return</span> <span class="n">one</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">other</span><span class="o">);</span>
	    <span class="o">}</span>
	<span class="o">});</span>     

</code></pre></td></tr></table>
</div>
</div><p>Java 8引入了Lambda之后，我们不必再引入一个对象来封装我们的排序逻辑：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">	<span class="n">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">values</span><span class="o">,</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">));</span>
</code></pre></td></tr></table>
</div>
</div><p>本质上讲，传递进来的还是一个对象，只不过是因为Functional Interface的存在，我们可以<strong>假装</strong>传入的是一个函数。这一点在我们使用传入的对象时就更为明显: 我们不得不像使用对象一样通过调用apply方法来应用传入的<em>函数</em>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">T</span> <span class="nf">create</span><span class="o">(</span><span class="n">String</span> <span class="n">stringValue</span><span class="o">,</span> <span class="n">Function</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">instantiator</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">instantiator</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">stringValue</span><span class="o">);</span>
    <span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在纯粹的函数式编程语言中，高阶函数的使用则更为自然， 如在haskell中，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell">	<span class="n">add</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
	<span class="n">add</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>

	<span class="n">perform</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span>
	<span class="n">perform</span> <span class="n">a</span> <span class="n">b</span> <span class="n">action</span> <span class="ow">=</span> <span class="n">action</span> <span class="n">a</span> <span class="n">b</span>

	<span class="kr">let</span> <span class="n">result</span> <span class="ow">=</span> <span class="n">perform</span> <span class="mi">1</span> <span class="mi">1</span> <span class="n">add</span> 	
	<span class="o">//</span> <span class="n">result</span> <span class="ow">=</span> <span class="mi">2</span>

</code></pre></td></tr></table>
</div>
</div><p>既然函数可以作为参数传递，也可以作为返回值，那么函数之间的<strong>运算</strong>也就不足为奇了。以下是Haskell中用来组合（compose）函数的函数(对，这里没有写错，就是通过组合函数来生成更强大函数)。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell">	<span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span>
	<span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="n">f</span> <span class="n">g</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">f</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>利用(.)，我们可以对函数进行组合：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell">	<span class="n">plus</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
	<span class="n">plus</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

	<span class="n">double</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
	<span class="n">double</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>

	<span class="n">plusThenDouble</span> <span class="ow">=</span> <span class="n">double</span><span class="o">.</span><span class="n">plus</span>

	<span class="kr">let</span> <span class="n">result</span> <span class="ow">=</span> <span class="n">plusThenDouble</span> <span class="mi">1</span>
	<span class="o">//</span> <span class="n">result</span> <span class="ow">=</span> <span class="mi">4</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="科里化currying">科里化(Currying)</h3>
<p><a href="https://en.wikipedia.org/wiki/Currying">科里化</a>把一个（接收多个参数的函数）的运算转化为多个（只接收一个参数的函数）的运算。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell">	<span class="n">add</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
	<span class="n">add</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</code></pre></td></tr></table>
</div>
</div><p>函数add接收两个参数，返回两者的和。我们可以把函数add理解为接收一个参数a，然后返回一个函数addA。函数B接收另外一个参数B, 返回值则是A+B。那么1+2的例子就可以如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell">   <span class="n">add1</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
   <span class="n">add1</span> <span class="ow">=</span> <span class="n">add</span> <span class="mi">1</span>

   <span class="kr">let</span> <span class="n">result</span> <span class="ow">=</span> <span class="n">add1</span> <span class="mi">2</span> <span class="o">//</span> <span class="n">result</span> <span class="ow">=</span> <span class="mi">3</span>
</code></pre></td></tr></table>
</div>
</div><p>上面的例子中add1其实就是一个部分应用函数(Partial Applied Function)。</p>
<p>其实这就是函数式编程语言中代码重用的方式。面向对象语言通过继承和组合重用已有逻辑，函数式语言可以通过部分应用函数以及函数组合来实现代码复用。</p>
<p>本篇文章是函数式编程系列之一：</p>
<ol>
<li>函数式编程 101</li>
<li><a href="/posts/functional-programming-concepts-part-two/">函数式编程 101 (续)</a></li>
<li><a href="/posts/functional-programming-in-real-world/">函数式编程初体验 一</a></li>
<li><a href="/posts/functional-programming-in-real-world-2/">函数式编程初体验 二</a></li>
<li><a href="/posts/functional-programming-in-real-world-3/">函数式编程初体验 三</a></li>
</ol>

</article>



<script src="/livereload.js?port=1313&mindelay=10&v=2" data-no-instant defer></script></body>

</html>
