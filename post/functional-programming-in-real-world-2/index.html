<!DOCTYPE html>
<html lang="zh-CN">
<title>函数式编程初体验 (2) | Hugo 主题 MemE</title>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.67.1" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="http://localhost:1313/css/index.css">
<link rel="stylesheet" href="http://localhost:1313/css/classes.css">
<link rel="canonical" href="http://localhost:1313/post/functional-programming-in-real-world-2/">
<link rel="alternate" type="application/rss+xml" href="" title="Hugo 主题 MemE">

<body>

<header class="icons">
  
    <a href="http://localhost:1313/">Hugo 主题 MemE</a>
  
  
    <nav>
    
      <a href="/posts/" >
        
          文章
        
      </a>
    
      <a href="/categories/" >
        
          分类
        
      </a>
    
      <a href="/tags/" >
        
          标签
        
      </a>
    
      <a href="/about/" >
        
          关于
        
      </a>
    
      <a href="" >
        
          
        
      </a>
    
      <a href="" >
        
          
        
      </a>
    
    </nav>
  
  
</header>

<article>
  <header>
    <h1>函数式编程初体验 (2)</h1>
    <time datetime="2016-02-27T21:58:43&#43;08:00">February 27, 2016</time>
  </header>
  <p>在<a href="/posts/functional-programming-in-real-world/">上篇文章</a>中，我们实现的MarsRover已经支持三种基本命令操作了。这次我们来稍微完善下，添加<strong>从字符串解析出命令</strong>的功能。</p>
<h3 id="分析">分析</h3>
<p>传入的指令是一个字符串，每个字符对应一个命令。探测器支持的命令只有L，R和M。当遇到不支持的字符时，探测器不作出任何响应。在一般的编程语言中，可能会使用异常来处理无法支持的命令的情况。那么在Haskell中，我们有什么新的武器可以使用吗？ Yes， 那就是<a href="https://wiki.haskell.org/Maybe">Maybe</a> monad.</p>
<p>Maybe类型代表一种有状态的数据，亦即这个数据存在，也可能不存在。Maybe类型有两个值： Just a'和Nothing，分别对应了两种状态。那么在我们的问题中，我们可以让解析函数返回一个Maybe类型，当返回的是Just时，表示返回的是一个支持的命令；当返回Nothing时，表示遇到不支持的命令。</p>
<h3 id="实现">实现</h3>
<p>基于上面的分析，我们的parse函数可以实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">parse</span> <span class="ow">::</span> <span class="kt">Char</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Command</span>
<span class="nf">parse</span> <span class="n">c</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">c</span> <span class="kr">of</span>
    <span class="sc">&#39;L&#39;</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="kt">L</span>
    <span class="sc">&#39;R&#39;</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="kt">R</span>
    <span class="sc">&#39;M&#39;</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="kt">M</span>
    <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
</code></pre></td></tr></table>
</div>
</div><p>parse函数接收一个字符，返回一个Maybe Command。这里又一次使用了模式匹配。当遇到不支持的命令时，返回一个Nothing。</p>
<p>如此一来，我们的execute的实现也要做对应的改动，以支持Maybe类型的参数。之前的定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">execute</span> <span class="ow">::</span> <span class="kt">MarsRover</span> <span class="ow">-&gt;</span> <span class="kt">Command</span> <span class="ow">-&gt;</span> <span class="kt">MarsRover</span>
<span class="nf">execute</span> <span class="n">rover</span> <span class="n">command</span> <span class="ow">=</span>
    <span class="kr">case</span> <span class="n">command</span> <span class="kr">of</span>
        <span class="kt">L</span> <span class="ow">-&gt;</span> <span class="n">turnLeft</span> <span class="n">rover</span>
        <span class="kt">R</span> <span class="ow">-&gt;</span> <span class="n">turnRight</span> <span class="n">rover</span>
        <span class="kt">M</span> <span class="ow">-&gt;</span> <span class="n">move</span> <span class="n">rover</span>
</code></pre></td></tr></table>
</div>
</div><p>为了接收Maybe类型的参数，我们修改为如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">run</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Command</span> <span class="ow">-&gt;</span> <span class="kt">MarsRover</span> <span class="ow">-&gt;</span> <span class="kt">MarsRover</span>
<span class="nf">run</span> <span class="n">command</span> <span class="n">rover</span> <span class="ow">=</span>
    <span class="kr">case</span> <span class="n">command</span> <span class="kr">of</span>
        <span class="kt">Just</span> <span class="kt">L</span> <span class="ow">-&gt;</span> <span class="n">turnLeft</span> <span class="n">rover</span>
        <span class="kt">Just</span> <span class="kt">R</span> <span class="ow">-&gt;</span> <span class="n">turnRight</span> <span class="n">rover</span>
        <span class="kt">Just</span> <span class="kt">M</span> <span class="ow">-&gt;</span> <span class="n">move</span> <span class="n">rover</span>
        <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">rover</span>
</code></pre></td></tr></table>
</div>
</div><p>新的实现中，我们把execute重命名为run，并且修改了参数的顺序和类型。当run遇到Nothing的时候，他什么都不做，只是返回原始的rover实例。</p>
<p>验证一下, 正确。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span><span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="kr">let</span> <span class="n">cmd</span> <span class="ow">=</span> <span class="n">parse</span> <span class="sc">&#39;L&#39;</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">show</span> <span class="o">$</span> <span class="n">run</span> <span class="n">cmd</span> <span class="o">$</span> <span class="kt">MarsRover</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="kt">S</span>
    <span class="c1">-- 输出 MarsRover (0,0) E</span>

    <span class="kr">let</span> <span class="n">cmd</span> <span class="ow">=</span> <span class="n">parse</span> <span class="sc">&#39;W&#39;</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">show</span> <span class="o">$</span> <span class="n">run</span> <span class="n">cmd</span> <span class="o">$</span> <span class="kt">MarsRover</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="kt">S</span>
    <span class="c1">-- 输出 MarsRover (0,0) S</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="更近一步">更近一步</h3>
<p>如果我想支持一系列命令呢？如&quot;LMRWWWMM&quot;？使用Haskell的内置功能，我们可以轻松实现。</p>
<p>首先我们先定义了一个函数(&gt;)， 其作用于Haskell自带的组合函数(.)类似，只不过是作用的顺序相反。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="p">(</span><span class="o">&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span>
<span class="p">(</span><span class="o">&gt;</span><span class="p">)</span> <span class="n">f</span> <span class="n">g</span> <span class="ow">=</span> <span class="n">g</span><span class="o">.</span><span class="n">f</span>
</code></pre></td></tr></table>
</div>
</div><p>例如：我们有两个函数addOne和plusTwo，那么 addOne.plusTwo的结果是生成一个新的函数，对参数会先乘以2，然后对结果再加1。而addOne&gt;plusTwo则是先对参数加1，然后对结果乘以2。</p>
<p>用在我们下面的代码里面，就相当于对探测器执行了如下命令：M &gt; L &gt; M &gt; R &gt; M &gt; L &gt; M &gt; L &gt; M</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span><span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="kr">let</span> <span class="n">execute</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="n">id</span> <span class="o">$</span> <span class="n">map</span> <span class="n">run</span> <span class="o">$</span> <span class="n">map</span> <span class="n">parse</span> <span class="s">&#34;MLMRMLMRM&#34;</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">show</span> <span class="o">$</span> <span class="n">execute</span> <span class="o">$</span> <span class="kt">MarsRover</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="kt">S</span>
    <span class="c1">-- 输出 MarsRover (2,-3) S</span>
</code></pre></td></tr></table>
</div>
</div><p>execute定义这行需要略作解释。Haskel中($)是一个优先级较低低的右结合运算符，f $ g $ x 的计算与f(g(x))相同，都是从右向左做运算。 这行完成了以下操作：</p>
<p><img src="https://github.com/ddou/ddou.github.io/raw/source/static/images/map-flow.png" alt="map-flow"></p>
<ol>
<li>把MLMRMLMRM的每个字符解析为Command，第一步map操作的结果是一个Maybe Command类型的List，每个元素代表一个可能的Command。</li>
<li>对上一步生成的List继续执行map操作，map的结果是每一个Maybe Command被转化一个部分应用的函数（Partial Applied Function)。第二步的结果也是List，只是每个元素都是一个函数，每个函数代表了要在探测器上执行的一个操作。</li>
<li>对上一步生成的List执行foldl， 将上述List转化为一个函数，通过我们自定义的函数（&gt;）将所有操作组合从为一个函数。</li>
</ol>
<p>最终结果为MarsRover (2,-3) S， 读到这里的你可以心算下是否正确？</p>
<p>这次的功能改进里面，我们使用了Haskell的Maybe monad来处理非法命令的问题，还体会到了函数式编程简洁优美的语法， 代码可以看<a href="https://raw.githubusercontent.com/yutaodou/functional-programming-via-haskell/ab484f1676fbc945bc7e652431f659f533987a3c/examples/mars-rover.hs">这里</a>。</p>
<p>下篇我们继续，问题可以先抛出来：</p>
<blockquote>
<p>探测器要保存路径信息，需要将操作过程中所有的坐标信息都最终打印出来，怎么实现？</p>
</blockquote>
<p>本篇文章是函数式编程系列之一：</p>
<ol>
<li><a href="/posts/functional-programming-concepts/">函数式编程 101</a></li>
<li><a href="/posts/functional-programming-concepts-part-two/">函数式编程 101 (续)</a></li>
<li><a href="/posts/functional-programming-in-real-world/">函数式编程初体验 一</a></li>
<li>函数式编程初体验 二</li>
<li><a href="/posts/functional-programming-in-real-world-3/">函数式编程初体验 三</a></li>
</ol>

</article>



<script src="/livereload.js?port=1313&mindelay=10&v=2" data-no-instant defer></script></body>

</html>
