<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 子不语</title>
    <link>https://ddou.github.io/post/</link>
    <description>Recent content in Posts on 子不语</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 10 Oct 2022 18:10:17 +0800</lastBuildDate><atom:link href="https://ddou.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>你了解手里的锤子吗？</title>
      <link>https://ddou.github.io/posts/know-your-tools/</link>
      <pubDate>Mon, 10 Oct 2022 18:10:17 +0800</pubDate>
      
      <guid>https://ddou.github.io/posts/know-your-tools/</guid>
      <description>一次代码评审  在一个风和日丽的下午，团队正在进行每日代码评审。小 A 对着大屏幕上的代码说了句：“稍微停下， 我们这里是不是应该把if改写成守卫语句的方式？”。
// 示意代码 public List&amp;lt;String&amp;gt; doStuff(String input) { if( someCheck(input) ) { operation1(input); operation2(input); operation3(input); } }  这是一个很简短的方法，方法体除去if外，只有 3 行业务逻辑，貌似的确没有重构的必要。“就一个 5 行的方法，这样修改有什么意义呢？”，小 C 疑惑的问起来。
 “这样写，未来如果再添加新的if判断，会形成if嵌套循环的时候，造成代码不好阅读，还是使用守卫语句比较好，这也是《重构》那本书里推荐的处理方法。” 小 A坚持着自己的建议。
 “但这个方法并没有嵌套呀，也不影响阅读，现在进行这个改动，不是很有价值吧”，小 C 不太不赞同这个改动。
 类似这样的对话在日常的代码评审中经常会出现，可能是在这里建议我们提取一个工具方法以方便未来使用，或者是在那里建议使用某个设计模式。但他们都有相似点，这些建议本身都没有错，而且在某些场景下是非常有必要的，只是在当下这个场景却有些不合时宜，也没有太大价值。
哪一把的锤子  在多年的工作中，我们学习到了很多编程技巧、业界最佳实践，以及模式等，并在不经意间就凭直觉应用在每个功能中，或者作为建议输出在代码评审中。 这些动作就像我们下意识的呼吸、或者开车时踩油门和刹车一样，不用经过大脑的过多思考。但就像上面发生在上面代码评审中的一样，场景不同，一个本来正确的做法可能就变成了正确但无价值的建议。
 不同的重构技巧是在解决不同的代码坏味道，不同的架构风格是在解决不同场景下的问题。那怎么知道哪个锤子对应在哪个钉子上呢？ 这就需要拨开重重表象迷雾，回归到问题的根源，也就是想马斯克一样，使用第一性原理从源头思考问题。
 以上面代码评审的为例子：如何评价一段代码的优劣呢？ 我们可以遵循下面的原则：
 功能是否被正确的实现？ 是否遵循了系统目前的设计实现方式？ 是否增加了系统的认知负荷？ 当发生变化时，是否容易修改？  当我们以这样的原则去审视上面的代码时，发现它的确没有重构的必要。
当我们采用某个实践、工具时，总是应该思考背后要遵循的原则，要达到的目的，以及最初的需求。
结局  “我理解你的意思，防卫语句在解决嵌套if的场景下，的确比较有价值，能让代码更容易阅读和维护。但是在这个方法里，的确没有必要，因为方法本身比较短小，功能正确，实现也清晰明了，建议目前保存现状。如果这个方法下次被改动，并且有出现if嵌套时，再修改为防卫语句吧。” 小 C 总结道。</description>
    </item>
    
    <item>
      <title>从丑到美： 简化 Lambda 操作</title>
      <link>https://ddou.github.io/posts/simplify-lambda-operation/</link>
      <pubDate>Sat, 28 May 2022 18:01:31 +0800</pubDate>
      
      <guid>https://ddou.github.io/posts/simplify-lambda-operation/</guid>
      <description>作为软件工程师， 工作的大部分时间我都在写代码，或者阅读别人的代码。期间，看到过许多优雅的代码，也见过糟糕的实现。 这个代码匠艺系列会分享一些优雅的实现，以及代码重构的经历。
本篇为该系列的第一篇。
Java 8 为集合类操作引入了 Stream。 可以创建 Stream 或者将集合类转化为 Stream 实例，通过传入 Lambda 表达式实现一系列的过滤、转化操作。理想情况下，Stream 和 Lambda 相结合可以写出清晰易懂的代码。但现实情况并非总是如此。比如下面这段代码：
private String renderPipelineScript(JenkinsPipeline pipeline) { PipelineScript pipelineScript = pipeline.renderScript(); pipelineScript.setExecutionRule(nonNull(pipeline.getExecutionRule()) ? pipeline.getExecutionRule() : &amp;#34;STOP&amp;#34;); ofNullable(pipelineScript.getStages()).ifPresent(stages -&amp;gt; stages.forEach(stage -&amp;gt; { stage.setQualityGateType(isNull(stage.getQualityGateType()) ? LanguageType.Maven : stage.getQualityGateType()); stage.setQualityGateContainer(isNull(stage.getQualityGateContainer()) ? &amp;#34;maven:3.8.4-jdk-11&amp;#34; : stage.getQualityGateContainer()); ofNullable(stage.getSteps()).ifPresent(steps -&amp;gt; steps.forEach(this::renderStepScript)); })); return ciScriptTemplateHelper.renderPipelineScriptByTemplate(pipelineScript, &amp;#34;pipeline-script.ftl&amp;#34;); } 不难看出，这段代码是在一个持续集成流水线的限界上下文内，有一个 Pipeline 的模型大致如下。这段代码在将 Pipe 模型定义的流水线转化为 Jenkins 的流水线配置文件。
代码逻辑并不复杂，但阅读起来多少还是有些障碍，不够顺畅：
 嵌套的 Optional，isPresent, forEach 操作 stage的forEach内 lambda 操作略显复杂，不太能清晰。  下面就对上述代码做简单重构，以简化其阅读障碍，使之更清晰易懂。</description>
    </item>
    
    <item>
      <title>简析Spring Security</title>
      <link>https://ddou.github.io/posts/on-spring-security-architecture/</link>
      <pubDate>Fri, 13 May 2022 16:42:02 +0800</pubDate>
      
      <guid>https://ddou.github.io/posts/on-spring-security-architecture/</guid>
      <description>Spring Security 提供了灵活简便的方式进行服务安全相关的配置。如下，只需要简单几行代码即可完成一个基于 JWT Token 的 API 服务的认证设置：
@Configuration public class SecurityConfiguration extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(&amp;#34;/api/login&amp;#34;).permitAll() .anyRequest().authenticated() .and() .addFilterAt(new JWTAuthFilter(), BasicAuthenticationFilter.class); } } ​ 上述配置允许/api/login 匿名访问，其他所有 endpoint 都必须通过身份认证后使用。身份认证基于 JWT Token 实现， JWTAuthFilter 负责验证请求头中是否包含有效的身份认证信息。
​ 那么 Spring Security 提供灵活强大的配置方式背后，具体是怎么工作的呢？ 上述寥寥几行代码背后隐藏着哪些魔法呢？下面首先我们从 Spring Securtiy 的工作机制聊起。
Spring Security 工作机制 ​ Spring Security 对 Servlet 的安全实现时基于 Servlet Filter 实现的。首先，我们来看下一个典型的请求处理流程：
SpringMVC 应用在在处理 Web 请求时，会创建一个FilterChain，包含了一些列的 Filter 和与该请求 URI 匹配的 Servlet （DispatcherServlet）。 Spring Security 通过在处理请求的 FilterChain 中插入 security 相关的 Filter 来实现其功能：</description>
    </item>
    
    <item>
      <title>我的2021</title>
      <link>https://ddou.github.io/posts/2021-review/</link>
      <pubDate>Fri, 07 Jan 2022 23:42:02 +0800</pubDate>
      
      <guid>https://ddou.github.io/posts/2021-review/</guid>
      <description>2021 年是忙碌的一年。
新工作 2020 年 11 月初，离开了工作近 7 年的地方，加入了一家创业公司。在一个地方呆的太久，人多少会有些倦怠，向往着围城外面的世界。对于码农更是如此，特别是当围城外面有一个自己看好的团队和产品的创业公司向你伸出绿枝的时候。
新公司技术团队有仰慕多年的技术大牛带队，也有不少之前的老同事在，加上在一个资本狂热追逐的赛道上，一切看起来那么顺风顺水。自己也在负责一个子系统，虽然在一个全新的技术栈上开始工作，但得益于同事间的互相携持，工作进展也还算顺利。
创业公司九死一生，为什么你就是那个幸运儿？
当大家都觉得一切完备，只差东风的时候，公司快速经历了裁员、并购、遣散员工，然后，大部分人开始在年底自谋出路。经过几番思想斗争，又重回前单位，即将开始一段不算新的新工作。
得 虽然结局一点都不美好，但过程至少可圈可点。团队每个人在过去的一年里都在为产品尽心尽力，多少个夜晚企业微信群里此起彼伏的消息提醒，年会上大家的“曼妙”舞姿，KTV 里的声嘶力竭，都是「大家挥洒汗水」的见证。这注定是一段值得怀念的经历。
经过这一年，个人经历上「创业公司经历」这一项也可以勾上了。
五一假期全家出游算是这一年的亮点时刻了。5 月 1 日上午我还在家处理线上故障，下午已然全家组团出发北京。这是一个说走就走的旅行，还是要感谢老婆的行动力，不然这个假期就会变成我一直坚持的西安周边游了。这也是组团规模最大的家庭旅游，包括父母、岳父母、弟弟、弟妹、老婆以及两个小朋友。天安门广场、毛主席纪念堂、人民英雄纪念碑、故宫（更准确应该说故宫门口）、八达岭长城、鸟巢、水立方、圆明园、北京大学、清华大学、北京烤鸭、铜锅涮，虽然没有提前规划，但行程安排还比较合理，老少咸宜。
这一年有些波折，特别是年底的这 2 个月经历的一些事情，我更清楚的认识到自己远不是一个内心强大的人，也一直缺乏直面内心的深刻自省。
失 这是失去的一年。
在 2022 新年到了的那一刻，我觉得时针仿佛又驳回了一年前，还是当时的自己，没有成长，徒增了一岁。
因为这次的工作变动，我也深刻的体会了机会成本这个词。
2022 再出发 即将回归之前的单位，在新的一年里，一定要开始一段不一样的旅程。
两个小朋友提了很多次想去海边玩，也计划下今年的全家之旅，青岛或许是个不错的选择。
也要勇敢的直面内心，更真实和纯粹。
有规划，也要坚持执行！</description>
    </item>
    
    <item>
      <title>闲谈软件系统中的复杂度</title>
      <link>https://ddou.github.io/posts/on-software-module/</link>
      <pubDate>Tue, 21 Apr 2020 22:50:34 +0800</pubDate>
      
      <guid>https://ddou.github.io/posts/on-software-module/</guid>
      <description>现在的软件项目大多越来越复杂，随着上线时间日久，业务持续变更，开发人员一波一波的轮换，产品到后期时，改动日渐困难，上线时间遥遥无期。类似的系统之所以复杂， 其中部分原因是由于业务本身的复杂性，另外一部分的复杂度则是来自于开发阶段，也就是说由开发阶段不合理的设计和实现引入的。 不合理的设计和实现导致系统僵硬和脆弱，难以修改，难以重用，容易出错。模块化是应对复杂系统的一种常用办法。
模块化 分而治之是我们在面临复杂问题时常用的应对手法。按照MECE的原则，我们把复杂问题分解为一个个更简单的小问题，然后各个击破。微服务设计中的做法是把整个问题域划分为多个子域，每个子域对应一个受限上下文(bounded context), 进而每个受限上下文可以对应到一个微服务。每个微服务有各自的职责，包含该问题子域内的业务逻辑。多个微服务之间协作共同为上层提供业务能力。
在单个组件内部，代码被组织到不同的模块内。模块级别的实现上，则是把模块职责做更细的划分，对应到不同的类实现不同的职责。
模块之间通过提供的接口彼此交互。模块可以以不同的形式对外提供接口：
 API 外部可访问的数据结构 外部可访问的函数 共享文件或内存  模块之间的耦合的方式也会因不同的接口方式而有所不同。模块化带来最大的好处是通过接口来提供其功能，而隐藏了功能的实现细节。模块的使用者仅仅关心接口的使用，而不必关注于功能的实现方式。基于模块化的系统设计，能带来显而易见的好处：
高层次快速理解系统结构
通过梳理系统模块结构，理清各个模块的职责，对外提供的接口，我们可以快速从高层次快速理解系统的结构。C4 模型是经常用来可视化系统架构一个工具。其中的组件图(Component Diagram)就展示了系统模块结构：
细节层面的功能开发
当深入代码细节时，开发人员这更多关注于当前模块，而不必关心所依赖模块的细节。这样就避免了将太多逻辑装载进脑中，降低认知复杂度。
有了模块和接口，模块间互相配合也完成了功能，然后呢？
简单接口 Java 开发人员对 Java 中文件读取的操作应该都有很深刻的印象：
FileInputStream fileStream = new FileInputStream(fileName); BufferedInputStream bufferedStream = new BufferedInputStream(fileStream); ObjectInputStream objectStream = new ObjectInputStream(bufferedStream); 当我们想读取一个包含序列化对象的文件时，必须要手动构建一个FileInputStream, BufferedInputStream， 然后才是ObjectInputStream。虽然这样的设计提供了足够的灵活度，但对用户而言，这是非常的不友好。
在《软件设计的哲学》中，John Ousterhout 提出 Deep Module 的概念：
 “The best modules are deep: they allow a lot of functionality to be accessed through a simple interface.</description>
    </item>
    
    <item>
      <title>AWS专家级解决方案架构师认证(SAP)备考指北</title>
      <link>https://ddou.github.io/posts/sap-certificate/</link>
      <pubDate>Mon, 30 Dec 2019 17:57:02 +0800</pubDate>
      
      <guid>https://ddou.github.io/posts/sap-certificate/</guid>
      <description>一个Flag 年中上一个项目结束，回到阔别已久的西安，进入一个相对稳定的项目。 了解到AWS调整了AWS专家级解决方案架构师认证(SAP)的条件，取消了助理级解决方案架构师(SAA)的限制条件，可以直接进行专业级别的认证。作为一个在AWS平台上摸爬滚打的大概4年的老鸟，我觉得也应该是时候经过一次考试的洗礼，全面而细致的梳理下已有知识，并重新认识AWS平台上的各种服务。于是，一个flag就这么立了起来。从8月中开始准备，到12月初通过考试，耗时大概3个月。下面就把这三个月的复习备考过程分享给需要的朋友。
AWS一共推出了上图中的11个认证考试，涵盖了不同的专业方向以及难度级别。其中AWS Solution Architect解决方案架构师认证更多是关注AWS平台上的架构设计，比如使用AWS平台上的各种服务设计一个安全、稳定可靠、伸缩性好、性能优越，并且可运维的系统。除了架构设计外，系统和数据迁移、企业环境下AWS网络规划、成本控制等也是考试的要点。
AWS解决方案架构师认证有两个级别：助理级解决方案架构师(SAA)和专家级解决方案架构师(SAP)。2018年10月之后, AWS取消了参加SAP认证必须要先通过SAA认证的前提要求，给应试者更大的灵活性。在申请专业级认证前，应试者不再需要获得助理级认证，并且在申请专项认证之前，应试者不再需要获得云从业者认证或助理级认证。
考试内容 SAP的考试一共涵盖上述5部分内容：
 复杂组织环境下的设计  这部分主要考察复杂组织环境下的系统设计，如一个组织，有多个业务线（Business unit),、复杂的合规要求以及多变的扩展性需求，在该环境下，如何进行鉴权以及访问控制，如何规划AWS网络以满足跨VPC、Account或者和自有数据中心网络互通等。
在平时工作中，我们更多是关注与系统的设计和实现，大部分人没有太多机会能在上述复杂环境下进行实操，这也是个人认为在学习过程中最有挑战和花费时间最多的部分。
 设计新解决方案  如何基于AWS平台设计一个新的解决方案，在满足业务需求的同时，满足性能、可靠性、伸缩行、经济行等非功能性需求。这部分更多考察对AWS核心服务的理解，如EC2, EBS, S3, IAM, Security group, RDS, API Gateway, Lambda, SNS, SQS等。
 迁移规划  系统和数据从自有数据中心向AWS平台迁移。
 成本控制  如何以最具成效比的方式架构系统
 现有系统优化  考试形式 考试题型全部为选择题，有单选题和多选题之分。如果是多选题，题目会标示有几个正确选项。
相比较于SAA认证，SAP在题目的难度上有非常大的提升。SAA重在于对AWS各个服务功能的理解，偏概念性，题目也较为直接，如：
而SAP考试则更偏重知识的实际应用，场景更为复杂，如下例所示：
如果选择英语作为考试语言，那么SAP的考试首先面对的是3个小时的英语阅读理解，然后才是背后的AWS认证考试。
这样的题目更类似于日常工作的场景：给出一个假设的业务场景，有具体的期望目标以及各种约束，然后给出解决方案。除了理解AWS各种服务的功能、特性、使用场景、限制外，SAP还需要有更多的实战经验和更多架构上的理解，所以说SAP是难度最高的AWS认证考试也不为过。估计这也是为什么AWS建议按照推荐的学习路径逐步学习，再进行SAP认证的原因了。
复习规划 每年的AWS reinvent都是一次狂欢，大家都期盼着新的服务发布，帮大家解决实际问题。经过一轮轮狂欢，AWS的服务也涵盖了方方面面。对准备考试而言，这可不是什么值得高兴的事情，AWS服务控制台中一页已经不能完整列出所有的服务了。
关注重点
如此之多的服务，每个服务都达到同样的熟悉程度是不现实的，那就只能重点关注了。我订阅了两个月的acloud.gugu(这里真的没有广告)，基于上面SAP相关的视频，把主要的服务快速了解一遍。经过这一轮，整理出了一个学习列表，把相关服务按照领域归类，逐个学习了解。
 对于已经比较了解的服务，快速跳过； 对于比较重要但之前接触不多的服务，相关的FAQ/文档/用户案例/白皮书快速看一遍。 对于不太常用的服务，更多是看FAQ，了解服务基本功能，以及用户案例。  定期检查
acloud.gugu（真心没有广告）的另外一个功能是模拟考试，大概有100道题。可以通过完成这些题目，检查学习的情况，查漏补缺。另外，AWS官方也有一份例题，虽然没有答案的，按时对于了解考试题型还是非常有帮助的。
除了上述外，网上也有不少例题资源，如www.examtopics.com, 这里有网络上收集整理的AWS考试例题。每个题目下都有评论和讨论，这里也是检查复习成果、查漏补缺的好去处。
资料
SAP认证并没有AWS官方的备考指南之类的资料，更多是需要自己基于个人情况复习。个人经验而言，下面几种形式的复习资料比较有效：
  SAP认证视频教程
A Cloud Guru和Linux Academy均有相关视频教程。通过这些视频教程，快速了解AWS各种服务、以及每个服务的功能要点，还是比较有效的。</description>
    </item>
    
    <item>
      <title>你的代码不干净</title>
      <link>https://ddou.github.io/posts/clean-code-discussion/</link>
      <pubDate>Tue, 23 Jul 2019 15:34:30 +0800</pubDate>
      
      <guid>https://ddou.github.io/posts/clean-code-discussion/</guid>
      <description>“你这个代码写的不 clean 呀， 你看这里的 order 是个 double 类型的， 为什么不用整型的呢？”。在一次讨论中，对方给出这么个结论。
关于设计的讨论基本是程序员的日常。在讨论中，各种“大帽子”会飞过来,飞过去， Clean、SOLID、扩展性、可测试性、复杂度等等。如果对“帽子”本身的内涵不理解，被扣帽子的人就么办法做出合理的为自己的代码辩护。扣帽子的人则是在调皮捣蛋。 比如上面的场景，clean 是指什么？当对方说代码不 clean 的时候，他又在指什么？
按照需求，页面上需要显示出一系列表单控件，order 则标记着各个控件的显示顺序。实际实现中，每个控件实例有个 order 属性，按照 order 排序后，逐个显示即满足需求。上面的实现是能完全满足 Kent Beck 在简单设计(Simple design)中提高的 4 个要求的:
 测试通过 明确表达代码意图 没有重复 最小化实现，没有冗余  额外的好处，就是简单，易理解， 维护也方便。当有更多的组件需要插入到现有列表中时，也总是可以找到一个位置。另外，即使如对方所言换成整型，也没有本质的区别。
按照我们对整洁代码的理解，这个实现是满足要求的。但对方指的不 clean, 具体是什么呢？是不满足需求？还是有其他隐情？真相是作为非技术人员，对方只是纯粹觉得整数比带小数点的浮点数更“干净”！
这就是典型的讨论双方对 clean 没有共识，也就是所谓的鸡同鸭讲。这时，就需要理解内涵的一方开始耐心的科普：首先我们定义一下什么是 X, 然后再讨论为什么 Y 不 X。
好的程序员，不仅要有一双巧手写出优雅的代码，还要缜密理论知识织就的铁布衫，随时抵御飞来的大帽子。</description>
    </item>
    
    <item>
      <title>功能π的敏捷之旅</title>
      <link>https://ddou.github.io/posts/real-world-agile-delivery/</link>
      <pubDate>Tue, 22 Aug 2017 17:58:10 +0800</pubDate>
      
      <guid>https://ddou.github.io/posts/real-world-agile-delivery/</guid>
      <description>本文里会以一个功能 π 的开发流程为例，展示公司内一个敏捷团队的软件开发实践。
项目背景 客户 R 是澳洲最大的在线房地产广告平台。公司团队是协助 R 客户创建一个针对中国市场的房产信息广告平台，用来展示澳洲以及其他海外房产，方便国内投资者。
作为一个全功能的交付团队，整个团队的人员一共 11 人，成员包括 TL _ 1、BA _ 1、UX _ 1、QA _ 1、Ops _ 1、Dev _ 6。客户方面 Delivery Lead _ 1 和 Product Owner _ 1, 两人都在澳洲。
客户负责提供项目的 Roadmap，优先级以及初步的需求。后续由公司开发团队完成从需求分析、交互设计、功能设计、实现、测试、以及部署上线的全生命周期的工作。
功能 π 的敏捷之旅 下面以一个功能 π 的开发流程为例，展示笔者所在项目的开发实践。
计划 项目的路线图 Roadmap 是由 Trello 来管理的。Epic 需求会由客户 PO 记录在 Trello 中。Trello board 中设置的有不同的列，如 Backlog, Planned, Next, In progress, Completed 等。每列中卡片由上而下代表优先级的递减。Trello board 作为项目 high level 需求的管理工具，可以很直观的了解项目整体的进展状况。
每两周全团队会进行一次计划会议，类似 IPM，但是主要是根据 Roadmap 上的优先级，确定近期的开发计划。最终的输出是一个具体的 task 列表。其中会包括:</description>
    </item>
    
    <item>
      <title>[译文]再谈CAP理论</title>
      <link>https://ddou.github.io/posts/cap-theorem-revisited-translation/</link>
      <pubDate>Tue, 09 May 2017 23:58:10 +0800</pubDate>
      
      <guid>https://ddou.github.io/posts/cap-theorem-revisited-translation/</guid>
      <description>最近在看分布式相关文章时，偶遇该篇文章，文章虽简短，但分析透彻, 故译来与大家分享，希望能读者有帮助。
译文如下
当今技术领域，我们经常碰到这样一种情况：希望通过增加额外的资源，如（计算能力，存储等）来横向扩展系统，以期能成功在合理的时间内完成请求处理。这是通过给系统添加商用硬件（commodity hardware）来应对不断增加的负载。该扩展策略导致的一个问题就是系统复杂度升高。该场景下 CAP 理论就要起作用了。
CAP 理论陈述如下： 在一个分布式系统中(一个由多个共享数据又互相连接的计算机节点组成的系统)，对于一次数据读/写操作对，只能得到如下三个保证中的两个： 一致性，可用性，分区容错性， 其中之一必然被牺牲。
 The CAP Theorem states that, in a distributed system (a collection of interconnected nodes that share data.), you can only have two out of the following three guarantees across a write/read pair: Consistency, Availability, and Partition Tolerance - one of them must be sacrificed.
 如下图所示，我们并没有太多选择：
 一致性  对于一个给定的客户端，一次读操作总是确保返回最近一次写操作。
 可用性  一个正常工作的节点总是在合理的时间范围内返回合理的响应。
 分区容错性  当出现网络分区时，系统也可以继续工作。</description>
    </item>
    
    <item>
      <title>一个Dash的替代解决方案</title>
      <link>https://ddou.github.io/posts/dash-alternative/</link>
      <pubDate>Fri, 08 Apr 2016 22:13:23 +0800</pubDate>
      
      <guid>https://ddou.github.io/posts/dash-alternative/</guid>
      <description>作为一个合格的码农，都与自己的工具箱。
如果讲到查看文档，Dash 必须是排第一位的。但是$29.99 的售价的确让不少人望而却步。
好在软件的世界里，总有替代品可见，DevDocs就是一个查看文档除 Dash 外的绝好选择。DevDocs 提供了与 Dash 类似的功能，只不过是基于网页的应用使用起来多少会有些不习惯。
那能不能自己封装一下呢？一个好的办法就是Electron。
于是乎，就有了DevDocs-Wrapper，通过 Electron 封装 DevDocs 来提供类似与桌面应用的体验，见下图：
可以从DevDocs-Wrapper自行下载代码打包。</description>
    </item>
    
    <item>
      <title>函数式编程初体验 (3)</title>
      <link>https://ddou.github.io/posts/functional-programming-in-real-world-3/</link>
      <pubDate>Sat, 19 Mar 2016 11:43:26 +0800</pubDate>
      
      <guid>https://ddou.github.io/posts/functional-programming-in-real-world-3/</guid>
      <description>书接上回。在上篇文章中，我们的火星探测器已经可以解析命令字符串，并且按照命令执行探测任务。新的功能要求我们在这个基础上，增加记录探测器历史位置信息的功能，以保留一份活动位置记录，以避免后期在某个区域重复探测。
分析 使用我们主流的编程语言，上述功能可以很简单的实现，比如采用如下两个方式：
 定义一个全局变量，保存历史位置信息，每次移动探测器时，添加最近的位置信息 在 MarsRover 类中新添一个变量，保存历史位置信息，每次移动都将最近的位置信息添加到变量中  上述两种方式都可以正确的实现功能。但是在我们函数式编程的大背景下，使用是上述任一种方式，都是与函数式编程的理念相违背的： 纯函数的实现是没有副作用的，即不会修改全局状态，也不会修改参数的状态。那有什么办法呢？
不论使用何种范式的编程语言，有一些公共的问题都是在程序中需要解决的，例如异常处理，IO，全局状态等需要副作用的场景。只是不同的语言解决问题的方式不同。函数式编程在解决如上述问题时，有自己的思路。Monad就是函数式编程语言用来解决上述问题的利器。
Monad 从本质上理解 Monad，需要范畴论（Category Theory）的知识，这也导致了 Monad 不太容易理解。简单的讲，Monad 是封装了一个计算上下文(Computation Context), 正是因为这一点，monad 也被称为“可编程的分号”。
有一个类型的 Monad，大部分人都应该都有过了解。那就是Maybe Monad。Maybe 在很多语言里面都有对应的实现。Java 8 中对应的实现为java.util.Optional。Optional 代表一个可能存在的值，针对两种不同的存在状态，同一个方法调用会有不同的执行逻辑， 例如：
Optional&amp;lt;Integer&amp;gt; integer = Optional.of(&amp;#34;123&amp;#34;).map(str -&amp;gt; Integer.parseInt(str)); Optional&amp;lt;Integer&amp;gt; empty = Optional.&amp;lt;String&amp;gt;empty().map(str -&amp;gt; Integer.parseInt(str)); 如果我们查看 Optional 的源码，可以看到 map 方法的实现，针对了两种不同的存在状态做了不同的处理。这就是 Optional 所包含的所谓计算上下文，也是 Monad 的价值所在。
public&amp;lt;U&amp;gt; Optional&amp;lt;U&amp;gt; map(Function&amp;lt;? super T, ? extends U&amp;gt; mapper) { Objects.requireNonNull(mapper); if (!isPresent()) return empty(); else { return Optional.ofNullable(mapper.apply(value)); } } 类似的，我们也可以通过 Monad 来实现保存 MarsRover 的历史位置数据。</description>
    </item>
    
    <item>
      <title>函数式编程初体验 (2)</title>
      <link>https://ddou.github.io/posts/functional-programming-in-real-world-2/</link>
      <pubDate>Sat, 27 Feb 2016 21:58:43 +0800</pubDate>
      
      <guid>https://ddou.github.io/posts/functional-programming-in-real-world-2/</guid>
      <description>在上篇文章中，我们实现的 MarsRover 已经支持三种基本命令操作了。这次我们来稍微完善下，添加从字符串解析出命令的功能。
分析 传入的指令是一个字符串，每个字符对应一个命令。探测器支持的命令只有 L，R 和 M。当遇到不支持的字符时，探测器不作出任何响应。在一般的编程语言中，可能会使用异常来处理无法支持的命令的情况。那么在 Haskell 中，我们有什么新的武器可以使用吗？ Yes， 那就是Maybe monad.
Maybe 类型代表一种有状态的数据，亦即这个数据存在，也可能不存在。Maybe 类型有两个值： Just a&amp;rsquo;和 Nothing，分别对应了两种状态。那么在我们的问题中，我们可以让解析函数返回一个 Maybe 类型，当返回的是 Just 时，表示返回的是一个支持的命令；当返回 Nothing 时，表示遇到不支持的命令。
实现 基于上面的分析，我们的 parse 函数可以实现如下：
parse :: Char -&amp;gt; Maybe Command parse c = case c of &amp;#39;L&amp;#39; -&amp;gt; Just L &amp;#39;R&amp;#39; -&amp;gt; Just R &amp;#39;M&amp;#39; -&amp;gt; Just M _ -&amp;gt; Nothing parse 函数接收一个字符，返回一个 Maybe Command。这里又一次使用了模式匹配。当遇到不支持的命令时，返回一个 Nothing。
如此一来，我们的 execute 的实现也要做对应的改动，以支持 Maybe 类型的参数。之前的定义如下：
execute :: MarsRover -&amp;gt; Command -&amp;gt; MarsRover execute rover command = case command of L -&amp;gt; turnLeft rover R -&amp;gt; turnRight rover M -&amp;gt; move rover 为了接收 Maybe 类型的参数，我们修改为如下:</description>
    </item>
    
    <item>
      <title>函数式编程初体验 （1）</title>
      <link>https://ddou.github.io/posts/functional-programming-in-real-world/</link>
      <pubDate>Sat, 27 Feb 2016 21:58:43 +0800</pubDate>
      
      <guid>https://ddou.github.io/posts/functional-programming-in-real-world/</guid>
      <description>在之前的两篇函数式编程语言特性的文章（上篇和下篇）中简单介绍了一些基本的函数式编程的概念。对函数式编程有了一些基本的概念，那现实中的函数式编程是什么样子的呢？这里就选取一个比较简单的问题，使用 Haskell 尝试解决一下，以求近距离的感受下函数之美。
问题 这里采用的是我司一个废弃了很久的面试题目 MarsRover，题目内容如下：
 A squad of robotic rovers are to be landed by NASA on a plateau on Mars. This plateau, which is curiously rectangular, must be navigated by the rovers so that their on-board cameras can get a complete view of the surrounding terrain to send back to Earth. A rover&amp;rsquo;s position and location is represented by a combination of x and y co-ordinates and a letter representing one of the four cardinal compass points.</description>
    </item>
    
    <item>
      <title>函数式编程 101 (续)</title>
      <link>https://ddou.github.io/posts/functional-programming-concepts-part-two/</link>
      <pubDate>Mon, 18 Jan 2016 21:57:55 +0800</pubDate>
      
      <guid>https://ddou.github.io/posts/functional-programming-concepts-part-two/</guid>
      <description>上一篇提到了函数式编程语言的两个特点。这里书接上回，我们继续探讨函数式编程语言的其他特点。
尾递归 递归是我们在编程中处理集合时经常用的到的一个技巧，使用递归相对于循环来说可以更容易的实现功能。比如说求一个整数 num 的阶乘，采用递归可以实现如下：
private static Integer factorial(int num) { if (num == 1) { return 1; } return num * factorial(num - 1); } Integer result = factorial(10); // result = 3628800 上述递归的实现清晰易懂，结果正确。但是一个问题是，每当 factorial 调用自身时，如当 num=8 时，都会在调用堆栈上保存当前的执行上下文，当回调结束时以计算当前 num(8)和 factorial(7)的乘积。我们知道 每个程序在执行时，系统分配的堆栈大小都是有限制的。当回调足够多时，如 num 大，就可能出现堆栈溢出的错误。
一个解决该问题的办法就是采用尾递归。比如采用尾递归的方式实现阶乘计算如下：
private static Integer factorial2(int accu, int num) { if (num == 1) { return accu; } return factorial2(accu * num, num - 1); } Integer result = factorial2(1, 10); // result = 3628800 上述 factorial2 的实现中，中间的计算结果是以参数 accu 的方式传递给递归调用的函数，此时无需等递归函数调用结束再计算，故无需保存调用上下文，避免了堆栈操作，也就避免了因递归调用太多而导致的堆栈溢出问题。</description>
    </item>
    
    <item>
      <title>函数式编程 101</title>
      <link>https://ddou.github.io/posts/functional-programming-concepts/</link>
      <pubDate>Tue, 12 Jan 2016 21:07:54 +0800</pubDate>
      
      <guid>https://ddou.github.io/posts/functional-programming-concepts/</guid>
      <description>函数式编程这几年变得越来越流行起来，越来越多的语音融入了函数式编程的语法，就连更新缓慢如 Java 也不例外，在 Java8 中引入了函数式编程的语法。JVM 平台的后起之秀 Scala，Groovy 更是出生之初就有内置了对函数式编程的支持。作为最经常被拿来与 Java 做比较的 C#，更是抢先一步在.NET 3.5 版本时就有了对函数式编程的支持。后来.NET 平台上更是直接引入了函数式编程语言 F#。
函数式编程的兴起并非没有原因。
 函数式编程语言一般极具表现力. 相比主流的面向对象语言能以极少的代码完成相同的工作。与代码量的减少相对应的就是维护成本的降低。 相对于命令式编程，函数式编程语言都是采用声明式编程的方式，能在更高的抽象级别上编程，代码更易于理解。 **纯函数是没有副作用的，既不会修改全局状态，也不会修改传入的参数。**在进行多线程编程时，就从根本上避免死锁，活锁或者是线程饥饿的问题。  函数式编程语言的特征 高阶函数 在函数式编程语言中，函数终于成为一等公民，可以跟变量一样作为参数传递，同时也可以作为函数返回值返回。这个功能带来的直接好处就是当我们需要传递行为的时候，不必在跟之前一样为了传递行为而引入一个对象。例如在 Java 8 之前，当我们想排序一个 List 时：
List&amp;lt;Integer&amp;gt; values = newArrayList(11, 2, 43, 14, 5, 76, 6); Collections.sort(values, new Comparator&amp;lt;Integer&amp;gt;() { @Override public int compare(Integer one, Integer other) { return one.compareTo(other); } }); Java 8 引入了 Lambda 之后，我们不必再引入一个对象来封装我们的排序逻辑：
Collections.sort(values, (a, b) -&amp;gt; a.compareTo(b)); 本质上讲，传递进来的还是一个对象，只不过是因为 Functional Interface 的存在，我们可以假装传入的是一个函数。这一点在我们使用传入的对象时就更为明显: 我们不得不像使用对象一样通过调用 apply 方法来应用传入的函数。</description>
    </item>
    
    <item>
      <title>持续集成介绍</title>
      <link>https://ddou.github.io/posts/continuous-integration-introduction/</link>
      <pubDate>Sun, 10 Jan 2016 23:24:57 +0800</pubDate>
      
      <guid>https://ddou.github.io/posts/continuous-integration-introduction/</guid>
      <description>近期客户到访，按客户要求，做了持续集成方面的 session 分享。持续集成在 ThoughtWorks 每个项目中算是标准配置，必不可少，自己所在项目持续集成也是做的风生水起。正好依此为契机，总结下过去在持续集成方面的知识。有兴趣的朋友，可以参考持续集成简介。
欢迎探讨。</description>
    </item>
    
    <item>
      <title>你应该知道的Gmail</title>
      <link>https://ddou.github.io/posts/the-gmail-feature-you-should-know/</link>
      <pubDate>Sun, 20 Dec 2015 00:01:32 +0800</pubDate>
      
      <guid>https://ddou.github.io/posts/the-gmail-feature-you-should-know/</guid>
      <description>平日工作都是使用 Gmail 作为主力邮箱。虽然网页版因为要频繁登录，而多有不便，但在尝试了多种邮件客户端后，终究还是因为怀念 Gmail 网页版的强大功能，继续使用网页版。趁这个周末忙里偷得半日闲，暂且记录下自己在使用 Gmail 时的一些心得。
标签 Label 标签功能在不少邮箱产品中都支持，比如 Outlook，QQ Mail 等。使用标签功能，可以很方便的对邮件进行分类。Gmail 中的标签可以在左侧列表中显示，这样就可以很方便的通过点击相应标签，找到对应的邮件列表。
另外，Gmail 的标签是支持层次的，所以可以按照自己的需要对标签进行组织，比如可以把各种通知邮件，如账单，快递进度提醒，论坛提醒，订阅邮件等按照不同标签如“账单”、“提醒”、“订阅”等，组织在“通知”标签下，使邮件组织更加清晰明了。
自定义收件箱 Inbox Gmail 中可以对收件箱中邮件的显示进行配置。默认，Gmail 提供了 5 中类型的配置，分别是默认，重要优先，未读优先，加星标优先，和优先级邮件优先。对每一种类型，都可以在此基础上做配置。我个人还是比较喜欢优先级邮件优先。在原有配置的基础上，做些许改动：
按照上面的配置，收件箱中邮件会按照如下显示：
 系统识别为重要的邮件以及未读邮件 All Action 这部分是所有 Label 为 Action 的邮件，也就是需要我采取下一步行动的邮件，比如稍后需要回复，需要预定会议室等等。 其他已读的邮件。  上述配置的好处就是每次进入收件箱，该做什么都一目了然了。
过滤器 Filters 有 Label 功能固然好，但是如果 Label 都要手动添加上去的话，这个功能的作用就大打折扣了。Gmail 中 Filter 才是让 Label 威力无限的催化剂。
通过自定义 Filter，我们可以做些什么呢？
 跳过 Inbox，直接归档不重要的邮件 删除邮件 给邮件加星标 给邮件加 Label 自动 forward 邮件 &amp;hellip;  自定义 Filter，然后给符合某种规则的邮件自动添加 Label，自动归档，可以让邮件自动归类，把重要邮件从无足轻重的邮件堆里面标记出来，方便更高效的邮件处理。
Filter 的规则可以针对邮件的发件人，收件人，邮件标题，邮件大小，以及内容进行设置。如以下规则：
// 当发件人是ddou或者andytesii时，匹配 FROM: ddou@qq.</description>
    </item>
    
    <item>
      <title>一个NullPointerException引发的思考</title>
      <link>https://ddou.github.io/posts/thoughts-on-a-null-pointer-exception/</link>
      <pubDate>Sun, 26 Oct 2014 16:19:35 +0800</pubDate>
      
      <guid>https://ddou.github.io/posts/thoughts-on-a-null-pointer-exception/</guid>
      <description>近日在做项目中导出功能的重构，在中间执行单元测试验证功能时，出现一个java.lang.NullPointerException。这个异常对于每日与Exception和Bug打交道的同学们来说，是再熟悉不过的了。NullPointerException，亦即空指针异常，这是当在一个null对象上调用某个方法引起的。按图索骥，定位了产生异常的那行代码。错误信息和代码如下所示（写了个简单的，方便演示）：
Exception in thread &amp;#34;main&amp;#34; java.lang.NullPointerException at BuildingFeatures.getBedRooms(BuildingFeatures.java:8) at Test.main(Test.java:4) System.out.printl(buildingFeatures.getBedrooms()); 分析 根据经验来讲，这无疑是讲buildingFeatures这个变量是null。于是乎，设断点，重新执行测试，让我意外的是buildingFeatures竟然不是null？WTF？一瞬间，我陷入了陈思、迷茫，多年编程构建起来的世界观，价值观开始慢慢地松动、塌陷。
时间还在继续，无奈，虽然简单如一个getter方法，还是跟进去一探究竟吧。BuildingFeatures只是一个简单的类，典型的贫血模型，除了几个field，默认构造函数，以及对应的getter和setter，再无其他了。
public class BuildingFeatures { private Integer bedRooms; public BuildingFeatures() { } public int getBedRooms() { return bedRooms; } public void setBedRooms(Integer bedRooms) { this.bedRooms = bedRooms; } } 狐狸再狡猾，也逃不过猎人的眼睛，终于还是被我发现了问题之所在。问题出在了getter的返回值上。getter返回的是一个int，原始类型，而bedRooms这个field的类型是Integer，在getter内会进行类型的转换，也就是所谓的“拆箱”。要将一个null的Integer值拆箱，抛出一个NullPointerException也就不足为奇了。那getter中具体执行了哪些操作导致这个NullPointerException呢？ 我们还是从编译产生的bytecode中一探究竟吧。
深入分析 javap是一个用来反编译java类文件的小工具，在java的默认安装中有提供。通过如下命令可以看下getter中都执行了哪些操作：
javap -c out/production/untitled/BuildingFeatures.class 以下是输出：
public class BuildingFeatures { public BuildingFeatures(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&amp;quot;&amp;lt;init&amp;gt;&amp;quot;:()V 4: return public int getBedRooms(); Code: 0: aload_0 1: getfield #2 // Field bedRooms:Ljava/lang/Integer; 4: invokevirtual #3 // Method java/lang/Integer.</description>
    </item>
    
    <item>
      <title>RSpec优雅验证之Predicate Matcher</title>
      <link>https://ddou.github.io/posts/meaningful-rspec-predicate/</link>
      <pubDate>Sat, 08 Mar 2014 22:44:00 +0800</pubDate>
      
      <guid>https://ddou.github.io/posts/meaningful-rspec-predicate/</guid>
      <description>Ruby 作为动态语言，以其灵活性在测试领域大放异彩。RSpec 作为 Ruby 中使用最广泛的测试工具之一，实在是广大码农们居家旅行测试验证之必备神器。RSpec 提供了强大灵活的验证器(mather)，使用这些验证器加上 Ruby 灵活的语法可以写出类似于自然语言的验证，例如：
result_list.should include(item) result.should equal(item) person.name.should == &amp;#39;ddou&amp;#39; 上述验证写法自然看起来赏心悦目，但如下的写法就太不 ruby 了，估计 rubyist 看到了多少会有些反胃：
person.manager?.should be_true detail_view.toggleable?.should == true detail_view.has_photo?.should == true 对于上述验证，一个 rubyist 所喜闻乐见的验证写法应该是这样的：
person.should be_manager detail_view.should be_toggleable detail_view.should have_photo 这样的写法是不是看起来更自然，更符合人类自然语言的习惯？强大如 RSpec 者自然支持上述语法。RSpec 提供了对 Predicate Matcher 的支持，即可以使用被验证对象自身提供的 predicate 方法作为验证器。 常见的 predicate 方法如 Array.empty?，以及我们上面例子中的 Person.manager?，DetailView.toggleable?，DetailView.has_photo?等。
Predicate Matcher 实现 下面我们就打开 RSpec 源码，看看 Predicate Matcher 是如何实现。
上例中我们并没有定义 be_manager，be_toggleable 方法，RSpec 自然要依赖 Ruby 的强大元编程能力来实现魔法。打开 rspec-expectation 包下 lib/rspec/matchers/method_missing.rb 文件，我们可以看到如下逻辑：</description>
    </item>
    
  </channel>
</rss>
