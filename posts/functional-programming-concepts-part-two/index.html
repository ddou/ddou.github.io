<!DOCTYPE html>
<html lang="en-us">
<title>函数式编程 101 (续) | 子不语</title>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.67.1" />
<meta name="description" content="Some description">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://ddou.github.iocss/index.css">
<link rel="stylesheet" href="https://ddou.github.iocss/classes.css">
<link rel="canonical" href="https://ddou.github.io/posts/functional-programming-concepts-part-two/">
<link rel="alternate" type="application/rss+xml" href="" title="子不语">

<body>

<header class="icons">
  
    <a href="https://ddou.github.io">子不语</a>
  
  
    <nav>
    
      <a href="https://ddou.github.io/" >
        
          文章
        
      </a>
    
      <a href="https://ddou.github.io/tags/" >
        
          标签
        
      </a>
    
      <a href="https://ddou.github.io/about/" >
        
          关于
        
      </a>
    
      <a href="https://ddou.github.io/index.xml" >
        
          订阅
        
      </a>
    
    </nav>
  
  
    <div class="hidden description">Some description</div>
  
</header>

<article>
  <header>
    <h1>函数式编程 101 (续)</h1>
    <time
      datetime="2016-01-18T21:57:55&#43;08:00">January 18, 2016</time>
      

<small><code><a href="https://ddou.github.io/tags/functional-programming">Functional Programming</a></code></small>


<small><code><a href="https://ddou.github.io/tags/haskell">Haskell</a></code></small>

  </header>
  <p><a href="http://ddou.github.io/posts/functional-programming-concepts/">上一篇</a>提到了函数式编程语言的两个特点。这里书接上回，我们继续探讨函数式编程语言的其他特点。</p>
<h3 id="尾递归">尾递归</h3>
<p>递归是我们在编程中处理集合时经常用的到的一个技巧，使用递归相对于循环来说可以更容易的实现功能。比如说求一个整数num的阶乘，采用递归可以实现如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> Integer <span style="color:#a6e22e">factorial</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> num<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>num <span style="color:#f92672">==</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> 1<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> num <span style="color:#f92672">*</span> factorial<span style="color:#f92672">(</span>num <span style="color:#f92672">-</span> 1<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

Integer result <span style="color:#f92672">=</span> factorial<span style="color:#f92672">(</span>10<span style="color:#f92672">);</span>
<span style="color:#75715e">// result = 3628800
</span></code></pre></div><p>上述递归的实现清晰易懂，结果正确。但是一个问题是，每当factorial调用自身时，如当num=8时，都会在调用堆栈上保存当前的执行上下文，当回调结束时以计算当前num(8)和factorial(7)的乘积。我们知道
每个程序在执行时，系统分配的堆栈大小都是有限制的。当回调足够多时，如num大，就可能出现堆栈溢出的错误。</p>
<p>一个解决该问题的办法就是采用尾递归。比如采用尾递归的方式实现阶乘计算如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> Integer <span style="color:#a6e22e">factorial2</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> accu<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> num<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>num <span style="color:#f92672">==</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> accu<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> factorial2<span style="color:#f92672">(</span>accu <span style="color:#f92672">*</span> num<span style="color:#f92672">,</span> num <span style="color:#f92672">-</span> 1<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

Integer result <span style="color:#f92672">=</span> factorial2<span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> 10<span style="color:#f92672">);</span>
<span style="color:#75715e">// result = 3628800
</span></code></pre></div><p>上述factorial2的实现中，中间的计算结果是以参数accu的方式传递给递归调用的函数，此时无需等递归函数调用结束再计算，故无需保存调用上下文，避免了堆栈操作，也就避免了因递归调用太多而导致的堆栈溢出问题。</p>
<p>对集合进行操作是编程中的一个永恒主题。函数式编程语言中内置了许多对集合进行操作的函数，其中很多都是采用尾递归式的实现。如haskell中求阶乘:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">
<span style="color:#66d9ef">let</span> values <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">10</span>]
<span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> foldl (<span style="color:#a6e22e">\</span>x y <span style="color:#f92672">-&gt;</span> x <span style="color:#f92672">*</span> y) <span style="color:#ae81ff">1</span> values
<span style="color:#f92672">//</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">3628800</span>

</code></pre></div><h3 id="模式匹配pattern-matching">模式匹配（Pattern Matching）</h3>
<p>我们大部分程序都是在对数据进行解构，并基于数据内容进行不同的处理。函数式编程语言一般都支持模式匹配，模式匹配可以方便我们解构数据，并对不同的数据采用不同的处理方式。假设我们有如下数据定义：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">
<span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Category</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Book</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">Food</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">Medical</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">Other</span>

<span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Product</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Product</span> <span style="color:#66d9ef">String</span> <span style="color:#66d9ef">Float</span> <span style="color:#66d9ef">Category</span>

</code></pre></div><p>这里我们定义了两个数据结构，Category和Product。Product具有三个属性，name, price和category。假设对不同商品，我们有不同的消费税计算逻辑，在支持模式匹配的语言中我们可以如下实现：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">getTax</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Product</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Float</span>
<span style="color:#a6e22e">getTax</span> product <span style="color:#f92672">=</span> <span style="color:#66d9ef">case</span> product <span style="color:#66d9ef">of</span>
	(<span style="color:#66d9ef">Product</span> <span style="color:#66d9ef">_</span> price <span style="color:#66d9ef">Book</span>) <span style="color:#f92672">-&gt;</span> price <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.05</span> <span style="color:#f92672">//</span> <span style="color:#960050;background-color:#1e0010">书籍适用税率</span><span style="color:#ae81ff">0.05</span>
	(<span style="color:#66d9ef">Product</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">Food</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#ae81ff">0.0</span>	<span style="color:#f92672">//</span> <span style="color:#960050;background-color:#1e0010">食品免税</span>
	(<span style="color:#66d9ef">Product</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">_</span> <span style="color:#66d9ef">Medical</span>) <span style="color:#f92672">-&gt;</span> <span style="color:#ae81ff">0.0</span> <span style="color:#f92672">//</span> <span style="color:#960050;background-color:#1e0010">药品免税</span>
	(<span style="color:#66d9ef">Product</span> <span style="color:#66d9ef">_</span> price <span style="color:#66d9ef">_</span>) <span style="color:#f92672">-&gt;</span> price <span style="color:#ae81ff">0.1</span> <span style="color:#f92672">//</span> <span style="color:#960050;background-color:#1e0010">其他商品</span> <span style="color:#ae81ff">0.1</span><span style="color:#960050;background-color:#1e0010">消费税</span>
</code></pre></div><h3 id="纯函数pure-function">纯函数(Pure Function)</h3>
<p>我们可以利用高中时代学到的函数的知识理解纯函数，例如y=x * x。对于函数y=x * x，它的执行结果只依赖于输入参数x，与执行上下文无关；它的执行也不会对执行上下文有任何的影响。在函数式编程语言中，纯函数也有与此类似的属性。我们可以说一个函数是纯函数，如果它满足一下两个<a href="https://en.wikipedia.org/wiki/Pure_function">条件</a>：</p>
<ul>
<li>输出结果只依赖于输入参数，相同的输入参数总能得到相同的输出结果。</li>
<li>函数的执行不对对外产生任何副作用，基本修改可变对象状态或者输出。</li>
</ul>
<p>我们当年学到的三角函数都是纯函数的典型：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">
let value <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">Sin</span><span style="color:#f92672">(</span>90<span style="color:#f92672">);</span>
let abs <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">abs</span><span style="color:#f92672">(-</span>1<span style="color:#f92672">);</span>
let min <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>1<span style="color:#f92672">,</span>2<span style="color:#f92672">);</span>

</code></pre></div><h3 id="声明式编程declarative-programming">声明式编程(Declarative Programming)</h3>
<p>我们经常见到的Java， C#， C++都是采用命令式编程。当我们要只执行一个操作的适合，需要通过一行行代码告诉计算机怎么去执行我们想要的操作，如最简单的求和：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> Integer <span style="color:#a6e22e">sum</span><span style="color:#f92672">(</span>List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> value<span style="color:#f92672">){</span>
    <span style="color:#66d9ef">int</span> total <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> value<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        total <span style="color:#f92672">+</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> total<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>声明式编程则是在更抽象的级别进行编程，只需告诉计算机要做什么。如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">
<span style="color:#66d9ef">let</span> values <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">10</span>]

<span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> sum values <span style="color:#f92672">//</span> <span style="color:#ae81ff">55</span>

<span style="color:#66d9ef">let</span> even_numbers <span style="color:#f92672">=</span> filter even [<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">10</span>] <span style="color:#f92672">//</span> [<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">6</span>,<span style="color:#ae81ff">8</span>,<span style="color:#ae81ff">10</span>]

<span style="color:#66d9ef">let</span> first_even <span style="color:#f92672">=</span> take <span style="color:#ae81ff">1</span> even_numbers <span style="color:#f92672">//</span> <span style="color:#ae81ff">2</span>

<span style="color:#66d9ef">let</span> sumOfEvenSquares <span style="color:#f92672">=</span> sum <span style="color:#f92672">$</span> map (<span style="color:#a6e22e">\</span>x <span style="color:#f92672">-&gt;</span> x<span style="color:#f92672">*</span>x) <span style="color:#f92672">$</span> filter even [<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">10</span>] <span style="color:#f92672">//</span> <span style="color:#ae81ff">220</span>

<span style="color:#66d9ef">let</span> squareTriangles <span style="color:#f92672">=</span> [(a,b,c) <span style="color:#f92672">|</span> a<span style="color:#f92672">&lt;-</span>[<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">10</span>], b <span style="color:#f92672">&lt;-</span> [<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">10</span>], c <span style="color:#f92672">&lt;-</span>[<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span><span style="color:#ae81ff">10</span>], a<span style="color:#f92672">*</span>a <span style="color:#f92672">+</span> b<span style="color:#f92672">*</span>b <span style="color:#f92672">=</span> c<span style="color:#f92672">*</span>c] <span style="color:#f92672">//</span> [(<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>),(<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">5</span>),(<span style="color:#ae81ff">6</span>,<span style="color:#ae81ff">8</span>,<span style="color:#ae81ff">10</span>),(<span style="color:#ae81ff">8</span>,<span style="color:#ae81ff">6</span>,<span style="color:#ae81ff">10</span>)]


</code></pre></div><p>相对于命令式编程，采用声明式编程的函数式编程语言更富有表现力，能通过更少的代码实现更多的逻辑，同时代码也更清晰易懂。这估计也是函数式编程语言能够流行的一个原因。</p>
<p>上面简单的介绍了函数式编程语言的一些基本特征。</p>
<p>本篇文章是函数式编程系列之一：</p>
<ol>
<li><a href="https://ddou.github.io/posts/functional-programming-concepts/">函数式编程 101</a></li>
<li>函数式编程 101 (续)</li>
<li><a href="https://ddou.github.io/posts/functional-programming-in-real-world/">函数式编程初体验 一</a></li>
<li><a href="https://ddou.github.io/posts/functional-programming-in-real-world-2/">函数式编程初体验 二</a></li>
<li><a href="https://ddou.github.io/posts/functional-programming-in-real-world-3/">函数式编程初体验 三</a></li>
</ol>

</article>
<div id="disqus_thread" style="margin: 0px 500px"></div>
<script>
    (function() { 
        var d = document, s = d.createElement('script');
        s.src = '//dytes.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


</body>

</html>
