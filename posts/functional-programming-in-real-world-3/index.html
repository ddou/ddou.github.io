<!DOCTYPE html>
<html lang="en-us">
<title>函数式编程初体验 (3) | 子不语</title>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.90.1" />
<meta name="description" content="分享了函数式编程的一些基本概念，使用 Haskell 编写简单函数演示函数式编程基本概念">
<meta name="keywords" content="Functional Programming, Haskell, 函数式编程">
<meta name="robots" content="index,follow"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://ddou.github.io/css/minimal.css">
<link rel="canonical" href="https://ddou.github.io/posts/functional-programming-in-real-world-3/">
<link rel="alternate" type="application/rss+xml" href="" title="子不语">

<header>
  
    <a href="https://ddou.github.io/" class="title">子不语</a>
  
  
    <nav>
    
      <a href="https://ddou.github.io/">文章</a>
    
      <a href="https://ddou.github.io/tags/">标签</a>
    
      <a href="https://ddou.github.io/about/">关于</a>
    
      <a href="https://ddou.github.io/index.xml">订阅</a>
    
    </nav>
  
</header>

<article>
  <header>
    <h1>函数式编程初体验 (3)</h1>
    <time
      datetime="2016-03-19T11:43:26&#43;08:00">March 19, 2016</time>
      

<small><code><a href="https://ddou.github.io/tags/functional-programming">Functional Programming</a></code></small>


<small><code><a href="https://ddou.github.io/tags/haskell">Haskell</a></code></small>

  </header>
  <p>书接上回。在<a href="https://ddou.github.io/posts/functional-programming-in-real-world-2/">上篇文章</a>中，我们的火星探测器已经可以解析命令字符串，并且按照命令执行探测任务。新的功能要求我们在这个基础上，增加记录探测器历史位置信息的功能，以保留一份活动位置记录，以避免后期在某个区域重复探测。</p>
<h3 id="分析">分析</h3>
<p>使用我们主流的编程语言，上述功能可以很简单的实现，比如采用如下两个方式：</p>
<ol>
<li>定义一个全局变量，保存历史位置信息，每次移动探测器时，添加最近的位置信息</li>
<li>在 MarsRover 类中新添一个变量，保存历史位置信息，每次移动都将最近的位置信息添加到变量中</li>
</ol>
<p>上述两种方式都可以正确的实现功能。但是在我们函数式编程的大背景下，使用是上述任一种方式，都是与函数式编程的理念相违背的： 纯函数的实现是没有副作用的，即不会修改全局状态，也不会修改参数的状态。那有什么办法呢？</p>
<p>不论使用何种范式的编程语言，有一些公共的问题都是在程序中需要解决的，例如异常处理，IO，全局状态等需要副作用的场景。只是不同的语言解决问题的方式不同。函数式编程在解决如上述问题时，有自己的思路。<a href="https://www.haskell.org/tutorial/monads.html">Monad</a>就是函数式编程语言用来解决上述问题的利器。</p>
<h3 id="monad">Monad</h3>
<p>从本质上理解 Monad，需要范畴论（Category Theory）的知识，这也导致了 Monad 不太容易理解。简单的讲，Monad 是封装了一个计算上下文(Computation Context), 正是因为这一点，monad 也被称为“可编程的分号”。</p>
<p>有一个类型的 Monad，大部分人都应该都有过了解。那就是<a href="https://en.wikibooks.org/wiki/Haskell/Understanding_monads/Maybe">Maybe Monad</a>。Maybe 在很多语言里面都有对应的实现。Java 8 中对应的实现为<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">java.util.Optional</a>。Optional 代表一个可能存在的值，针对两种不同的存在状态，同一个方法调用会有不同的执行逻辑， 例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Optional<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> integer <span style="color:#f92672">=</span> Optional<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;123&#34;</span><span style="color:#f92672">).</span><span style="color:#a6e22e">map</span><span style="color:#f92672">(</span>str <span style="color:#f92672">-&gt;</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">parseInt</span><span style="color:#f92672">(</span>str<span style="color:#f92672">));</span>
Optional<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> empty <span style="color:#f92672">=</span> Optional<span style="color:#f92672">.&lt;</span>String<span style="color:#f92672">&gt;</span>empty<span style="color:#f92672">().</span><span style="color:#a6e22e">map</span><span style="color:#f92672">(</span>str <span style="color:#f92672">-&gt;</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">parseInt</span><span style="color:#f92672">(</span>str<span style="color:#f92672">));</span>
</code></pre></div><p>如果我们查看 Optional 的源码，可以看到 map 方法的实现，针对了两种不同的存在状态做了不同的处理。这就是 Optional 所包含的所谓计算上下文，也是 Monad 的价值所在。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span><span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span> Optional<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">map</span><span style="color:#f92672">(</span>Function<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">super</span> T<span style="color:#f92672">,</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">extends</span> U<span style="color:#f92672">&gt;</span> mapper<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Objects<span style="color:#f92672">.</span><span style="color:#a6e22e">requireNonNull</span><span style="color:#f92672">(</span>mapper<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>isPresent<span style="color:#f92672">())</span>
        <span style="color:#66d9ef">return</span> empty<span style="color:#f92672">();</span>
    <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> Optional<span style="color:#f92672">.</span><span style="color:#a6e22e">ofNullable</span><span style="color:#f92672">(</span>mapper<span style="color:#f92672">.</span><span style="color:#a6e22e">apply</span><span style="color:#f92672">(</span>value<span style="color:#f92672">));</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>类似的，我们也可以通过 Monad 来实现保存 MarsRover 的历史位置数据。</p>
<h3 id="实现">实现</h3>
<p>首先，我们先定义 Log 数据类型。 按照功能要求，我们的 Log 是一些列的坐标点。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">Log</span> <span style="color:#f92672">=</span> [<span style="color:#66d9ef">Point</span>]
</code></pre></div><p>然后，我们定义一个自己的 monad：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">Logger</span> a <span style="color:#f92672">=</span>  <span style="color:#66d9ef">Logger</span> (a, <span style="color:#66d9ef">Log</span>)
    <span style="color:#66d9ef">deriving</span> (<span style="color:#66d9ef">Show</span>)

<span style="color:#a6e22e">execLogger</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Logger</span> a <span style="color:#f92672">-&gt;</span> (a, <span style="color:#66d9ef">Log</span>)
<span style="color:#a6e22e">execLogger</span> (<span style="color:#66d9ef">Logger</span> (a, log)) <span style="color:#f92672">=</span> (a, log)

<span style="color:#a6e22e">record</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">MarsRover</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Logger</span> <span style="color:#66d9ef">MarsRover</span>
<span style="color:#a6e22e">record</span> marsRover <span style="color:#f92672">=</span> <span style="color:#66d9ef">Logger</span> (marsRover, [point])
    <span style="color:#66d9ef">where</span> point <span style="color:#f92672">=</span> getPosition marsRover
</code></pre></div><p>我们定义的 monad 是一个新的数据类型 Logger，包含了 MarsRover 实例，和它对应的历史位置信息。同时，我们定义了:</p>
<ul>
<li>
<p>execLogger 方法</p>
<blockquote>
<p>用来从 Logger 中提取出 rover 和历史位置数据。</p>
</blockquote>
</li>
<li>
<p>record 方法</p>
<blockquote>
<p>记录 rover 当前位置信息，返回包含当前 rover 和当前坐标的 Logger 对象</p>
</blockquote>
</li>
</ul>
<p>下面是 Logger monad 的实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">Monad</span> <span style="color:#66d9ef">Logger</span> <span style="color:#66d9ef">where</span>
    return a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Logger</span> (a, <span style="color:#66d9ef">[]</span>)
    m <span style="color:#f92672">&gt;&gt;=</span> k <span style="color:#f92672">=</span> <span style="color:#66d9ef">let</span> (a, x) <span style="color:#f92672">=</span> execLogger m
                  n     <span style="color:#f92672">=</span> k a
                  (b, y) <span style="color:#f92672">=</span> execLogger n
              <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">Logger</span> (b, x <span style="color:#f92672">++</span> y)
</code></pre></div><p>我们实现了两个 monad typeclass 定义的方法：</p>
<ul>
<li>
<p>return</p>
<blockquote>
<p>用来将 MarsRover，转换成一个 Logger，也是我们 monad 实例的创建函数</p>
</blockquote>
</li>
<li>
<p>(&raquo;=)</p>
<blockquote>
<p>这里封装了我们的计算上下文，也就是累积保存位置信息的逻辑。(&raquo;=)函数接受两个参数，第一个参数是 Logger，亦即当前状态数据（rover+历史位置数据）。第二个参数是下一步要执行的操作。从(&raquo;=)的实现来看，首先使用 execLogger 提取出当前状态，历史状态信息保存为 x，rover 信息保存为 a；然后，执行下一步操作，操作结果为 n；再次用 execLogger 提取出操作结果，得到这一步产生的状态信息 y 和新的 rover 信息 b，然后将最终结果 b 和累积的位置数据 x++y 返回出去。</p>
</blockquote>
</li>
</ul>
<p>定义好了我们的 monad 后，对应的我们的 run 方法也要做些许的修改：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">run</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">Command</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">MarsRover</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Logger</span> <span style="color:#66d9ef">MarsRover</span>
<span style="color:#a6e22e">run</span> command rover <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">case</span> command <span style="color:#66d9ef">of</span>
        <span style="color:#66d9ef">Just</span> <span style="color:#66d9ef">L</span> <span style="color:#f92672">-&gt;</span> return <span style="color:#f92672">$</span> turnLeft rover
        <span style="color:#66d9ef">Just</span> <span style="color:#66d9ef">L</span> <span style="color:#f92672">-&gt;</span> return <span style="color:#f92672">$</span> turnRight rover
        <span style="color:#66d9ef">Just</span> <span style="color:#66d9ef">M</span> <span style="color:#f92672">-&gt;</span> (move&#39; rover) <span style="color:#f92672">&gt;&gt;=</span> record
        <span style="color:#66d9ef">Nothing</span> <span style="color:#f92672">-&gt;</span> return rover
    <span style="color:#66d9ef">where</span> move&#39; rover <span style="color:#f92672">=</span> return (move rover)
</code></pre></div><p>在新版本的 run 方法中，方法的返回值改成了我们的 Logger 类型，毕竟返回值里面是要包含我们的历史位置信息的。内部实现上并没有太大的变化，只是通过 return 来把返回值转换为 Logger，对于 move 操作来说，move 之后，记录下当前位置。</p>
<p>因为我们是要解析命令字符串，执行一系列指令，我们定义了一个用来将一系列指令顺序在 rover 上执行的方法 apply：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">apply</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Logger</span> <span style="color:#66d9ef">MarsRover</span> <span style="color:#f92672">-&gt;</span> [<span style="color:#66d9ef">MarsRover</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Logger</span> <span style="color:#66d9ef">MarsRover</span>] <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Logger</span> <span style="color:#66d9ef">MarsRover</span>
<span style="color:#a6e22e">apply</span> rover actions <span style="color:#f92672">=</span> <span style="color:#66d9ef">case</span> actions <span style="color:#66d9ef">of</span>
    <span style="color:#66d9ef">[]</span> <span style="color:#f92672">-&gt;</span>  rover
    (x<span style="color:#66d9ef">:</span>xs) <span style="color:#f92672">-&gt;</span> apply (rover <span style="color:#f92672">&gt;&gt;=</span> x) xs
</code></pre></div><p>apply 函数接受 2 个参数，第一个是一个 Logger 对象，包含 rover 的初始状态。第二个参数是一个数组，代表要执行在 rover 上的指令。返回的是 Logger 对象，包含了 rover 的最终状态和历史位置信息。</p>
<p>我们可以通过如下方式验证结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">main</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">IO</span>()
<span style="color:#a6e22e">main</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span>
    <span style="color:#66d9ef">let</span> rover <span style="color:#f92672">=</span> <span style="color:#66d9ef">MarsRover</span> (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">S</span>
    <span style="color:#66d9ef">let</span> actions <span style="color:#f92672">=</span> map run <span style="color:#f92672">$</span> map parse <span style="color:#e6db74">&#34;MLMRMLMRM&#34;</span>
    <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> apply (record rover) actions
    putStrLn <span style="color:#f92672">$</span> show result
    <span style="color:#75715e">-- Logger (MarsRover (2,-3) S,[(0,0),(0,-1),(1,-1),(1,-2),(2,-2),(2,-3)])</span>
</code></pre></div><p>上述输出中的[(0,0),(0,-1),(1,-1),(1,-2),(2,-2),(2,-3)]即为探测器的历史位置信息。</p>
<p>查看完整代码，看<a href="https://raw.githubusercontent.com/yutaodou/functional-programming-via-haskell/f5b9f9246c319821a9c9523e210608bf98c77cb5/examples/mars-rover.hs">这里</a></p>
<p>本篇文章是函数式编程系列之一：</p>
<ol>
<li><a href="https://ddou.github.io/posts/functional-programming-concepts/">函数式编程 101</a></li>
<li><a href="https://ddou.github.io/posts/functional-programming-concepts-part-two/">函数式编程 101 (续)</a></li>
<li><a href="https://ddou.github.io/posts/functional-programming-in-real-world/">函数式编程初体验 一</a></li>
<li><a href="https://ddou.github.io/posts/functional-programming-in-real-world-2/">函数式编程初体验 二</a></li>
<li>函数式编程初体验 三</li>
</ol>

</article>

<script src="https://utteranc.es/client.js"
        repo="ddou/ddou.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

<style>
    div.utterances {
        max-width: 80%;
        width: 60%;
    }
</style>

<script>
    (function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-40664887-1' , { 'siteSpeedSampleRate': 100 });
    ga('send', 'pageview');
    ga('set', 'anonymizeIp', true);
</script>



</html>
