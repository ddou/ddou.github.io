<!DOCTYPE html>
<html lang="en-us">
<title>函数式编程初体验 (3) | 子不语</title>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.67.1" />
<meta name="description" content="Some description">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://ddou.github.io/css/index.css">
<link rel="stylesheet" href="https://ddou.github.io/css/classes.css">
<link rel="canonical" href="https://ddou.github.io/posts/functional-programming-in-real-world-3/">
<link rel="alternate" type="application/rss+xml" href="" title="子不语">

<body>

<header class="icons">
  
    <a href="https://ddou.github.io/">子不语</a>
  
  
    <nav>
    
      <a href="https://ddou.github.io/" >
        
          文章
        
      </a>
    
      <a href="https://ddou.github.io/tags/" >
        
          标签
        
      </a>
    
      <a href="https://ddou.github.io/about/" >
        
          关于
        
      </a>
    
      <a href="https://ddou.github.io/index.xml" >
        
          订阅
        
      </a>
    
    </nav>
  
  
    <div class="hidden description">Some description</div>
  
</header>

<article>
  <header>
    <h1>函数式编程初体验 (3)</h1>
    <time
      datetime="2016-03-19T11:43:26&#43;08:00">March 19, 2016</time>
      

<small><code><a href="https://ddou.github.io/tags/functional-programming">Functional Programming</a></code></small>


<small><code><a href="https://ddou.github.io/tags/haskell">Haskell</a></code></small>

  </header>
  <p>书接上回。在<a href="https://ddou.github.io/posts/functional-programming-in-real-world-2/">上篇文章</a>中，我们的火星探测器已经可以解析命令字符串，并且按照命令执行探测任务。新的功能要求我们在这个基础上，增加记录探测器历史位置信息的功能，以保留一份活动位置记录，以避免后期在某个区域重复探测。</p>
<h3 id="分析">分析</h3>
<p>使用我们主流的编程语言，上述功能可以很简单的实现，比如采用如下两个方式：</p>
<ol>
<li>定义一个全局变量，保存历史位置信息，每次移动探测器时，添加最近的位置信息</li>
<li>在MarsRover类中新添一个变量，保存历史位置信息，每次移动都将最近的位置信息添加到变量中</li>
</ol>
<p>上述两种方式都可以正确的实现功能。但是在我们函数式编程的大背景下，使用是上述任一种方式，都是与函数式编程的理念相违背的： 纯函数的实现是没有副作用的，即不会修改全局状态，也不会修改参数的状态。那有什么办法呢？</p>
<p>不论使用何种范式的编程语言，有一些公共的问题都是在程序中需要解决的，例如异常处理，IO，全局状态等需要副作用的场景。只是不同的语言解决问题的方式不同。函数式编程在解决如上述问题时，有自己的思路。<a href="https://www.haskell.org/tutorial/monads.html">Monad</a>就是函数式编程语言用来解决上述问题的利器。</p>
<h3 id="monad">Monad</h3>
<p>从本质上理解Monad，需要范畴论（Category Theory）的知识，这也导致了Monad不太容易理解。简单的讲，Monad是封装了一个计算上下文(Computation Context), 正是因为这一点，monad也被称为“可编程的分号”。</p>
<p>有一个类型的Monad，大部分人都应该都有过了解。那就是<a href="https://en.wikibooks.org/wiki/Haskell/Understanding_monads/Maybe">Maybe Monad</a>。Maybe在很多语言里面都有对应的实现。Java 8中对应的实现为<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">java.util.Optional</a>。Optional代表一个可能存在的值，针对两种不同的存在状态，同一个方法调用会有不同的执行逻辑， 例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Optional<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> integer <span style="color:#f92672">=</span> Optional<span style="color:#f92672">.</span><span style="color:#a6e22e">of</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;123&#34;</span><span style="color:#f92672">).</span><span style="color:#a6e22e">map</span><span style="color:#f92672">(</span>str <span style="color:#f92672">-&gt;</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">parseInt</span><span style="color:#f92672">(</span>str<span style="color:#f92672">));</span>
Optional<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> empty <span style="color:#f92672">=</span> Optional<span style="color:#f92672">.&lt;</span>String<span style="color:#f92672">&gt;</span>empty<span style="color:#f92672">().</span><span style="color:#a6e22e">map</span><span style="color:#f92672">(</span>str <span style="color:#f92672">-&gt;</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">parseInt</span><span style="color:#f92672">(</span>str<span style="color:#f92672">));</span>
</code></pre></div><p>如果我们查看Optional的源码，可以看到map方法的实现，针对了两种不同的存在状态做了不同的处理。这就是Optional所包含的所谓计算上下文，也是Monad的价值所在。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span><span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span> Optional<span style="color:#f92672">&lt;</span>U<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">map</span><span style="color:#f92672">(</span>Function<span style="color:#f92672">&lt;?</span> <span style="color:#66d9ef">super</span> T<span style="color:#f92672">,</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">extends</span> U<span style="color:#f92672">&gt;</span> mapper<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Objects<span style="color:#f92672">.</span><span style="color:#a6e22e">requireNonNull</span><span style="color:#f92672">(</span>mapper<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>isPresent<span style="color:#f92672">())</span>
        <span style="color:#66d9ef">return</span> empty<span style="color:#f92672">();</span>
    <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> Optional<span style="color:#f92672">.</span><span style="color:#a6e22e">ofNullable</span><span style="color:#f92672">(</span>mapper<span style="color:#f92672">.</span><span style="color:#a6e22e">apply</span><span style="color:#f92672">(</span>value<span style="color:#f92672">));</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>类似的，我们也可以通过Monad来实现保存MarsRover的历史位置数据。</p>
<h3 id="实现">实现</h3>
<p>首先，我们先定义Log数据类型。 按照功能要求，我们的Log是一些列的坐标点。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">Log</span> <span style="color:#f92672">=</span> [<span style="color:#66d9ef">Point</span>]
</code></pre></div><p>然后，我们定义一个自己的monad：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">Logger</span> a <span style="color:#f92672">=</span>  <span style="color:#66d9ef">Logger</span> (a, <span style="color:#66d9ef">Log</span>)
    <span style="color:#66d9ef">deriving</span> (<span style="color:#66d9ef">Show</span>)

<span style="color:#a6e22e">execLogger</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Logger</span> a <span style="color:#f92672">-&gt;</span> (a, <span style="color:#66d9ef">Log</span>)
<span style="color:#a6e22e">execLogger</span> (<span style="color:#66d9ef">Logger</span> (a, log)) <span style="color:#f92672">=</span> (a, log)

<span style="color:#a6e22e">record</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">MarsRover</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Logger</span> <span style="color:#66d9ef">MarsRover</span>
<span style="color:#a6e22e">record</span> marsRover <span style="color:#f92672">=</span> <span style="color:#66d9ef">Logger</span> (marsRover, [point])
    <span style="color:#66d9ef">where</span> point <span style="color:#f92672">=</span> getPosition marsRover
</code></pre></div><p>我们定义的monad是一个新的数据类型Logger，包含了MarsRover实例，和它对应的历史位置信息。同时，我们定义了:</p>
<ul>
<li>
<p>execLogger方法</p>
<blockquote>
<p>用来从Logger中提取出rover和历史位置数据。</p>
</blockquote>
</li>
<li>
<p>record方法</p>
<blockquote>
<p>记录rover当前位置信息，返回包含当前rover和当前坐标的Logger对象</p>
</blockquote>
</li>
</ul>
<p>下面是Logger monad的实现：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">Monad</span> <span style="color:#66d9ef">Logger</span> <span style="color:#66d9ef">where</span>
    return a <span style="color:#f92672">=</span> <span style="color:#66d9ef">Logger</span> (a, <span style="color:#66d9ef">[]</span>)
    m <span style="color:#f92672">&gt;&gt;=</span> k <span style="color:#f92672">=</span> <span style="color:#66d9ef">let</span> (a, x) <span style="color:#f92672">=</span> execLogger m
                  n     <span style="color:#f92672">=</span> k a
                  (b, y) <span style="color:#f92672">=</span> execLogger n
              <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">Logger</span> (b, x <span style="color:#f92672">++</span> y)
</code></pre></div><p>我们实现了两个monad typeclass定义的方法：</p>
<ul>
<li>
<p>return</p>
<blockquote>
<p>用来将MarsRover，转换成一个Logger，也是我们monad实例的创建函数</p>
</blockquote>
</li>
<li>
<p>(&raquo;=)</p>
<blockquote>
<p>这里封装了我们的计算上下文，也就是累积保存位置信息的逻辑。(&raquo;=)函数接受两个参数，第一个参数是Logger，亦即当前状态数据（rover+历史位置数据）。第二个参数是下一步要执行的操作。从(&raquo;=)的实现来看，首先使用execLogger提取出当前状态，历史状态信息保存为x，rover信息保存为a；然后，执行下一步操作，操作结果为n；再次用execLogger提取出操作结果，得到这一步产生的状态信息y和新的rover信息b，然后将最终结果b和累积的位置数据x++y返回出去。</p>
</blockquote>
</li>
</ul>
<p>定义好了我们的monad后，对应的我们的run方法也要做些许的修改：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">run</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">Command</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">MarsRover</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Logger</span> <span style="color:#66d9ef">MarsRover</span>
<span style="color:#a6e22e">run</span> command rover <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">case</span> command <span style="color:#66d9ef">of</span>
        <span style="color:#66d9ef">Just</span> <span style="color:#66d9ef">L</span> <span style="color:#f92672">-&gt;</span> return <span style="color:#f92672">$</span> turnLeft rover
        <span style="color:#66d9ef">Just</span> <span style="color:#66d9ef">L</span> <span style="color:#f92672">-&gt;</span> return <span style="color:#f92672">$</span> turnRight rover
        <span style="color:#66d9ef">Just</span> <span style="color:#66d9ef">M</span> <span style="color:#f92672">-&gt;</span> (move&#39; rover) <span style="color:#f92672">&gt;&gt;=</span> record
        <span style="color:#66d9ef">Nothing</span> <span style="color:#f92672">-&gt;</span> return rover
    <span style="color:#66d9ef">where</span> move&#39; rover <span style="color:#f92672">=</span> return (move rover)
</code></pre></div><p>在新版本的run方法中，方法的返回值改成了我们的Logger类型，毕竟返回值里面是要包含我们的历史位置信息的。内部实现上并没有太大的变化，只是通过return来把返回值转换为Logger，对于move操作来说，move之后，记录下当前位置。</p>
<p>因为我们是要解析命令字符串，执行一系列指令，我们定义了一个用来将一系列指令顺序在rover上执行的方法apply：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">apply</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Logger</span> <span style="color:#66d9ef">MarsRover</span> <span style="color:#f92672">-&gt;</span> [<span style="color:#66d9ef">MarsRover</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Logger</span> <span style="color:#66d9ef">MarsRover</span>] <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Logger</span> <span style="color:#66d9ef">MarsRover</span>
<span style="color:#a6e22e">apply</span> rover actions <span style="color:#f92672">=</span> <span style="color:#66d9ef">case</span> actions <span style="color:#66d9ef">of</span>
    <span style="color:#66d9ef">[]</span> <span style="color:#f92672">-&gt;</span>  rover
    (x<span style="color:#66d9ef">:</span>xs) <span style="color:#f92672">-&gt;</span> apply (rover <span style="color:#f92672">&gt;&gt;=</span> x) xs
</code></pre></div><p>apply函数接受2个参数，第一个是一个Logger对象，包含rover的初始状态。第二个参数是一个数组，代表要执行在rover上的指令。返回的是Logger对象，包含了rover的最终状态和历史位置信息。</p>
<p>我们可以通过如下方式验证结果：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">main</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">IO</span>()
<span style="color:#a6e22e">main</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span>
    <span style="color:#66d9ef">let</span> rover <span style="color:#f92672">=</span> <span style="color:#66d9ef">MarsRover</span> (<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">S</span>
    <span style="color:#66d9ef">let</span> actions <span style="color:#f92672">=</span> map run <span style="color:#f92672">$</span> map parse <span style="color:#e6db74">&#34;MLMRMLMRM&#34;</span>
    <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> apply (record rover) actions
    putStrLn <span style="color:#f92672">$</span> show result
    <span style="color:#75715e">-- Logger (MarsRover (2,-3) S,[(0,0),(0,-1),(1,-1),(1,-2),(2,-2),(2,-3)])</span>
</code></pre></div><p>上述输出中的[(0,0),(0,-1),(1,-1),(1,-2),(2,-2),(2,-3)]即为探测器的历史位置信息。</p>
<p>查看完整代码，看<a href="https://raw.githubusercontent.com/yutaodou/functional-programming-via-haskell/f5b9f9246c319821a9c9523e210608bf98c77cb5/examples/mars-rover.hs">这里</a></p>
<p>本篇文章是函数式编程系列之一：</p>
<ol>
<li><a href="https://ddou.github.io/posts/functional-programming-concepts/">函数式编程 101</a></li>
<li><a href="https://ddou.github.io/posts/functional-programming-concepts-part-two/">函数式编程 101 (续)</a></li>
<li><a href="https://ddou.github.io/posts/functional-programming-in-real-world/">函数式编程初体验 一</a></li>
<li><a href="https://ddou.github.io/posts/functional-programming-in-real-world-2/">函数式编程初体验 二</a></li>
<li>函数式编程初体验 三</li>
</ol>

</article>
<div id="disqus_thread" style="margin: 0px 500px"></div>
<script>
    (function() { 
        var d = document, s = d.createElement('script');
        s.src = '//dytes.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


</body>

</html>
