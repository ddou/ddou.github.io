<!DOCTYPE html>
<html lang="en-us">
<title>RSpec优雅验证之Predicate Matcher | 子不语</title>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.90.1" />
<meta name="description" content="dytes 的个人博客，记录生活感悟，工作心得">
<meta name="baidu-site-verification" content="AAd4ZRAjIO">
<meta name="keywords" content="Ruby, 单元测试, RSpec">
<meta name="robots" content="index,follow"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="apple-touch-icon" sizes="180x180" href="https://ddou.github.io/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ddou.github.io/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://ddou.github.io/favicon-16x16.png">
<link rel="manifest" href="https://ddou.github.io/site.webmanifest">
<link rel="stylesheet" href="https://ddou.github.io/css/minimal.css">
<link rel="canonical" href="https://ddou.github.io/posts/meaningful-rspec-predicate/">
<link rel="alternate" type="application/rss+xml" href="" title="子不语">

<header>
  
    <a href="https://ddou.github.io/" class="title">子不语</a>
  
  
    <nav>
    
      <a href="https://ddou.github.io/">文章</a>
    
      <a href="https://ddou.github.io/tags/">标签</a>
    
      <a href="https://ddou.github.io/about/">关于</a>
    
      <a href="https://ddou.github.io/index.xml">订阅</a>
    
    </nav>
  
</header>

<article>
  <header>
    <h1>RSpec优雅验证之Predicate Matcher</h1>
    <time
      datetime="2014-03-08T22:44:00&#43;08:00">March 08, 2014</time>
      

<small><code><a href="https://ddou.github.io/tags/ruby">Ruby</a></code></small>


<small><code><a href="https://ddou.github.io/tags/test">Test</a></code></small>


<small><code><a href="https://ddou.github.io/tags/unit-test">Unit Test</a></code></small>


<small><code><a href="https://ddou.github.io/tags/rspec">RSpec</a></code></small>

  </header>
  <p>Ruby 作为动态语言，以其灵活性在测试领域大放异彩。RSpec 作为 Ruby 中使用最广泛的测试工具之一，实在是广大码农们居家旅行测试验证之必备神器。RSpec 提供了强大灵活的验证器(mather)，使用这些验证器加上 Ruby 灵活的语法可以写出类似于自然语言的验证，例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby">    result_list<span style="color:#f92672">.</span>should <span style="color:#66d9ef">include</span>(item)

    result<span style="color:#f92672">.</span>should equal(item)

    person<span style="color:#f92672">.</span>name<span style="color:#f92672">.</span>should <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;ddou&#39;</span>
</code></pre></div><p>上述验证写法自然看起来赏心悦目，但如下的写法就太不 ruby 了，估计 rubyist 看到了多少会有些反胃：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby">    person<span style="color:#f92672">.</span>manager?<span style="color:#f92672">.</span>should be_true

    detail_view<span style="color:#f92672">.</span>toggleable?<span style="color:#f92672">.</span>should <span style="color:#f92672">==</span> <span style="color:#66d9ef">true</span>

    detail_view<span style="color:#f92672">.</span>has_photo?<span style="color:#f92672">.</span>should <span style="color:#f92672">==</span> <span style="color:#66d9ef">true</span>
</code></pre></div><p>对于上述验证，一个 rubyist 所喜闻乐见的验证写法应该是这样的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby">    person<span style="color:#f92672">.</span>should be_manager

    detail_view<span style="color:#f92672">.</span>should be_toggleable

    detail_view<span style="color:#f92672">.</span>should have_photo
</code></pre></div><p>这样的写法是不是看起来更自然，更符合人类自然语言的习惯？强大如 RSpec 者自然支持上述语法。RSpec 提供了对 Predicate Matcher 的支持，即可以使用被验证对象自身提供的 predicate 方法作为验证器。 常见的 predicate 方法如 Array.empty?，以及我们上面例子中的
Person.manager?，DetailView.toggleable?，DetailView.has_photo?等。</p>
<h4 id="predicate-matcher-实现">Predicate Matcher 实现</h4>
<p>下面我们就打开 RSpec 源码，看看 Predicate Matcher 是如何实现。</p>
<p>上例中我们并没有定义 be_manager，be_toggleable 方法，RSpec 自然要依赖 Ruby 的强大元编程能力来实现魔法。打开 rspec-expectation 包下 lib/rspec/matchers/method_missing.rb 文件，我们可以看到如下逻辑：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby">    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">method_missing</span>(method, <span style="color:#f92672">*</span>args, <span style="color:#f92672">&amp;</span>block)
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">Matchers</span><span style="color:#f92672">::</span><span style="color:#66d9ef">BuiltIn</span><span style="color:#f92672">::</span><span style="color:#66d9ef">BePredicate</span><span style="color:#f92672">.</span>new(method, <span style="color:#f92672">*</span>args, <span style="color:#f92672">&amp;</span>block) <span style="color:#66d9ef">if</span> method<span style="color:#f92672">.</span>to_s <span style="color:#f92672">=~</span> <span style="color:#e6db74">/^be_/</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">Matchers</span><span style="color:#f92672">::</span><span style="color:#66d9ef">BuiltIn</span><span style="color:#f92672">::</span><span style="color:#66d9ef">Has</span><span style="color:#f92672">.</span>new(method, <span style="color:#f92672">*</span>args, <span style="color:#f92672">&amp;</span>block) <span style="color:#66d9ef">if</span> method<span style="color:#f92672">.</span>to_s <span style="color:#f92672">=~</span> <span style="color:#e6db74">/^have_/</span>
        <span style="color:#66d9ef">super</span>
    <span style="color:#66d9ef">end</span>
</code></pre></div><p>以上例中 be_manager 为例，此情况下 RSpec 会创建一个 Matchers::BuiltIn::BePredicate 实例，should 会使用该 BePredicate 来验证我们的期望值。下面我们顺藤摸瓜看下 BePredicate 是如何工作的：</p>
<ul>
<li>解析出验证使用的 Predicate 方法的名字，$3 返回即是。对于上例中 be_manager，此处返回&quot;manager&quot;。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby">    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">prefix_and_expected</span>(symbol)
      symbol<span style="color:#f92672">.</span>to_s <span style="color:#f92672">=~</span> <span style="color:#e6db74">/^(be_(an?_)?)(.*)/</span>
      <span style="color:#66d9ef">return</span> $1, $3
    <span style="color:#66d9ef">end</span>
</code></pre></div><ul>
<li>将上述方法名字转化为实际使用的 Predicate 方法对应的符号（Symbol）。根据时态的不同，还会在 Predicate 方法名后添加 s。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby">    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">predicate</span>
        <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">#{</span>@expected<span style="color:#e6db74">}</span><span style="color:#e6db74">?&#34;</span><span style="color:#f92672">.</span>to_sym
    <span style="color:#66d9ef">end</span>

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">present_tense_predicate</span>
        <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">#{</span>@expected<span style="color:#e6db74">}</span><span style="color:#e6db74">s?&#34;</span><span style="color:#f92672">.</span>to_sym
    <span style="color:#66d9ef">end</span>
</code></pre></div><ul>
<li>调用上述方法，验证结果。从具体 matches 方法的实现来看， RSpec 会首先尝试不加 s 的 Predicate 方法，如果失败才会继续尝试加 s 的方法。所以，我们的例子中，be_manager 会首先使用 manager？方法验证，如果失败会继续使用 managers？方法验证。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby">    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">matches?</span>(actual)
        @actual <span style="color:#f92672">=</span> actual
        <span style="color:#66d9ef">begin</span>
            <span style="color:#66d9ef">return</span> @result <span style="color:#f92672">=</span> actual<span style="color:#f92672">.</span>__send__(predicate, <span style="color:#f92672">*</span>@args, <span style="color:#f92672">&amp;</span>@block)
        <span style="color:#66d9ef">rescue</span> <span style="color:#66d9ef">NameError</span> <span style="color:#f92672">=&gt;</span> predicate_missing_error
            <span style="color:#e6db74">&#34;this needs to be here or rcov will not count this branch even though it&#39;s executed in a code example&#34;</span>
        <span style="color:#66d9ef">end</span>

        <span style="color:#66d9ef">begin</span>
            <span style="color:#66d9ef">return</span> @result <span style="color:#f92672">=</span> actual<span style="color:#f92672">.</span>__send__(present_tense_predicate, <span style="color:#f92672">*</span>@args, <span style="color:#f92672">&amp;</span>@block)
        <span style="color:#66d9ef">rescue</span> <span style="color:#66d9ef">NameError</span>
            <span style="color:#66d9ef">raise</span> predicate_missing_error
        <span style="color:#66d9ef">end</span>
    <span style="color:#66d9ef">end</span>
</code></pre></div><p>HasPredicate 的实现与 BePredicate 类似，此处不再累述。</p>
<p>到此，我们就了解了为什么下面这样的验证能正常工作了：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby">    person<span style="color:#f92672">.</span>should be_manager

    detail_view<span style="color:#f92672">.</span>should be_toggleable

    detail_view<span style="color:#f92672">.</span>should have_photo
</code></pre></div><p>既然了解了 RSpec 的 Predicate Matcher 功能，你还会写出本文初列出的那种 non-ruby 的验证代码吗？</p>

</article>

<script src="https://utteranc.es/client.js"
        repo="ddou/ddou.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

<style>
    div.utterances {
        max-width: 80%;
        width: 60%;
    }
</style>

<script>
    (function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-40664887-1' , { 'siteSpeedSampleRate': 100 });
    ga('send', 'pageview');
    ga('set', 'anonymizeIp', true);
</script>



</html>
