<!DOCTYPE html>
<html lang="en-us">
<title>函数式编程 101 | 子不语</title>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.67.1" />
<meta name="description" content="Some description">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://ddou.github.io/css/index.css">
<link rel="stylesheet" href="https://ddou.github.io/css/classes.css">
<link rel="canonical" href="https://ddou.github.io/posts/functional-programming-concepts/">
<link rel="alternate" type="application/rss+xml" href="" title="子不语">

<body>

<header class="icons">
  
    <a href="https://ddou.github.io/">子不语</a>
  
  
    <nav>
    
      <a href="https://ddou.github.io/" >
        
          文章
        
      </a>
    
      <a href="https://ddou.github.io/tags/" >
        
          标签
        
      </a>
    
      <a href="https://ddou.github.io/about/" >
        
          关于
        
      </a>
    
      <a href="https://ddou.github.io/index.xml" >
        
          订阅
        
      </a>
    
    </nav>
  
  
    <div class="hidden description">Some description</div>
  
</header>

<article>
  <header>
    <h1>函数式编程 101</h1>
    <time
      datetime="2016-01-12T21:07:54&#43;08:00">January 12, 2016</time>
      

<small><code><a href="https://ddou.github.io/tags/functional-programming">Functional Programming</a></code></small>


<small><code><a href="https://ddou.github.io/tags/haskell">Haskell</a></code></small>

  </header>
  <p>函数式编程这几年变得越来越流行起来，越来越多的语音融入了函数式编程的语法，就连更新缓慢如Java也不例外，在Java8中引入了函数式编程的语法。JVM平台的后起之秀Scala，Groovy更是出生之初就有内置了对函数式编程的支持。作为最经常被拿来与Java做比较的C#，更是抢先一步在.NET 3.5版本时就有了对函数式编程的支持。后来.NET平台上更是直接引入了函数式编程语言F#。</p>
<p>函数式编程的兴起并非没有原因。</p>
<ul>
<li><strong>函数式编程语言一般极具表现力</strong>. 相比主流的面向对象语言能以极少的代码完成相同的工作。与代码量的减少相对应的就是维护成本的降低。</li>
<li>相对于命令式编程，<strong>函数式编程语言都是采用声明式编程的方式</strong>，能在更高的抽象级别上编程，代码更易于理解。</li>
<li>**纯函数是没有副作用的，既不会修改全局状态，也不会修改传入的参数。**在进行多线程编程时，就从根本上避免死锁，活锁或者是线程饥饿的问题。</li>
</ul>
<h2 id="函数式编程语言的特征">函数式编程语言的特征</h2>
<h3 id="高阶函数">高阶函数</h3>
<p>在函数式编程语言中，函数终于成为一等公民，可以跟变量一样作为参数传递，同时也可以作为函数返回值返回。这个功能带来的直接好处就是当我们需要传递<strong>行为</strong>的时候，不必在跟之前一样为了传递行为而引入一个对象。例如在Java 8之前，当我们想排序一个List时：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">	List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> values <span style="color:#f92672">=</span> newArrayList<span style="color:#f92672">(</span>11<span style="color:#f92672">,</span> 2<span style="color:#f92672">,</span> 43<span style="color:#f92672">,</span> 14<span style="color:#f92672">,</span> 5<span style="color:#f92672">,</span> 76<span style="color:#f92672">,</span> 6<span style="color:#f92672">);</span>
	Collections<span style="color:#f92672">.</span><span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>values<span style="color:#f92672">,</span> <span style="color:#66d9ef">new</span> Comparator<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;()</span> <span style="color:#f92672">{</span>
	    <span style="color:#a6e22e">@Override</span>
	    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">compare</span><span style="color:#f92672">(</span>Integer one<span style="color:#f92672">,</span> Integer other<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
	        <span style="color:#66d9ef">return</span> one<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>other<span style="color:#f92672">);</span>
	    <span style="color:#f92672">}</span>
	<span style="color:#f92672">});</span>     

</code></pre></div><p>Java 8引入了Lambda之后，我们不必再引入一个对象来封装我们的排序逻辑：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">	Collections<span style="color:#f92672">.</span><span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>values<span style="color:#f92672">,</span> <span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> b<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>b<span style="color:#f92672">));</span>
</code></pre></div><p>本质上讲，传递进来的还是一个对象，只不过是因为Functional Interface的存在，我们可以<strong>假装</strong>传入的是一个函数。这一点在我们使用传入的对象时就更为明显: 我们不得不像使用对象一样通过调用apply方法来应用传入的<em>函数</em>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> T <span style="color:#a6e22e">create</span><span style="color:#f92672">(</span>String stringValue<span style="color:#f92672">,</span> Function<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span> T<span style="color:#f92672">&gt;</span> instantiator<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> instantiator<span style="color:#f92672">.</span><span style="color:#a6e22e">apply</span><span style="color:#f92672">(</span>stringValue<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>在纯粹的函数式编程语言中，高阶函数的使用则更为自然， 如在haskell中，</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">	add <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> a
	add a b <span style="color:#f92672">=</span> a <span style="color:#f92672">+</span> b

	perform <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> (a <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> a) <span style="color:#f92672">-&gt;</span> a
	perform a b action <span style="color:#f92672">=</span> action a b

	<span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> perform <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">1</span> add 	
	<span style="color:#f92672">//</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>

</code></pre></div><p>既然函数可以作为参数传递，也可以作为返回值，那么函数之间的<strong>运算</strong>也就不足为奇了。以下是Haskell中用来组合（compose）函数的函数(对，这里没有写错，就是通过组合函数来生成更强大函数)。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">	(<span style="color:#f92672">.</span>) <span style="color:#f92672">::</span> (b <span style="color:#f92672">-&gt;</span> c) <span style="color:#f92672">-&gt;</span> (a <span style="color:#f92672">-&gt;</span> b) <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> c
	(<span style="color:#f92672">.</span>) f g x <span style="color:#f92672">=</span> f(g(x))
</code></pre></div><p>利用(.)，我们可以对函数进行组合：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">	plus <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> a
	plus x <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>

	double <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> a
	double x <span style="color:#f92672">=</span> x <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>

	plusThenDouble <span style="color:#f92672">=</span> double<span style="color:#f92672">.</span>plus

	<span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> plusThenDouble <span style="color:#ae81ff">1</span>
	<span style="color:#f92672">//</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
</code></pre></div><h3 id="科里化currying">科里化(Currying)</h3>
<p><a href="https://en.wikipedia.org/wiki/Currying">科里化</a>把一个（接收多个参数的函数）的运算转化为多个（只接收一个参数的函数）的运算。例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">	add <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> a
	add a b <span style="color:#f92672">=</span> a <span style="color:#f92672">+</span> b
</code></pre></div><p>函数add接收两个参数，返回两者的和。我们可以把函数add理解为接收一个参数a，然后返回一个函数addA。函数B接收另外一个参数B, 返回值则是A+B。那么1+2的例子就可以如下所示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">   add1 <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> a
   add1 <span style="color:#f92672">=</span> add <span style="color:#ae81ff">1</span>

   <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> add1 <span style="color:#ae81ff">2</span> <span style="color:#f92672">//</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</code></pre></div><p>上面的例子中add1其实就是一个部分应用函数(Partial Applied Function)。</p>
<p>其实这就是函数式编程语言中代码重用的方式。面向对象语言通过继承和组合重用已有逻辑，函数式语言可以通过部分应用函数以及函数组合来实现代码复用。</p>
<p>本篇文章是函数式编程系列之一：</p>
<ol>
<li>函数式编程 101</li>
<li><a href="https://ddou.github.io/posts/functional-programming-concepts-part-two/">函数式编程 101 (续)</a></li>
<li><a href="https://ddou.github.io/posts/functional-programming-in-real-world/">函数式编程初体验 一</a></li>
<li><a href="https://ddou.github.io/posts/functional-programming-in-real-world-2/">函数式编程初体验 二</a></li>
<li><a href="https://ddou.github.io/posts/functional-programming-in-real-world-3/">函数式编程初体验 三</a></li>
</ol>

</article>
<div id="disqus_thread" style="margin: 0px 500px"></div>
<script>
    (function() { 
        var d = document, s = d.createElement('script');
        s.src = '//dytes.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


</body>

</html>
