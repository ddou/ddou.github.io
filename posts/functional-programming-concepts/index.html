<!DOCTYPE html>
<html lang="en-us">
<title>函数式编程 101 | 子不语</title>
<meta charset="utf-8">
<meta name="generator" content="Hugo 0.90.1" />
<meta name="description" content="分享了函数式编程的一些基本概念，使用 Haskell 编写简单函数演示函数式编程基本概念">
<meta name="baidu-site-verification" content="AAd4ZRAjIO">
<meta name="keywords" content="Functional Programming, Haskell, 函数式编程">
<meta name="robots" content="index,follow"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="apple-touch-icon" sizes="180x180" href="https://ddou.github.io/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ddou.github.io/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://ddou.github.io/favicon-16x16.png">
<link rel="manifest" href="https://ddou.github.io/site.webmanifest">
<link rel="stylesheet" href="https://ddou.github.io/css/minimal.css">
<link rel="canonical" href="https://ddou.github.io/posts/functional-programming-concepts/">
<link rel="alternate" type="application/rss+xml" href="" title="子不语">

<header>
  
    <a href="https://ddou.github.io/" class="title">子不语</a>
  
  
    <nav>
    
      <a href="https://ddou.github.io/">文章</a>
    
      <a href="https://ddou.github.io/tags/">标签</a>
    
      <a href="https://ddou.github.io/about/">关于</a>
    
      <a href="https://ddou.github.io/index.xml">订阅</a>
    
    </nav>
  
</header>

<article>
  <header>
    <h1>函数式编程 101</h1>
    <time
      datetime="2016-01-12T21:07:54&#43;08:00">January 12, 2016</time>
      

<small><code><a href="https://ddou.github.io/tags/functional-programming">Functional Programming</a></code></small>


<small><code><a href="https://ddou.github.io/tags/haskell">Haskell</a></code></small>

  </header>
  <p>函数式编程这几年变得越来越流行起来，越来越多的语音融入了函数式编程的语法，就连更新缓慢如 Java 也不例外，在 Java8 中引入了函数式编程的语法。JVM 平台的后起之秀 Scala，Groovy 更是出生之初就有内置了对函数式编程的支持。作为最经常被拿来与 Java 做比较的 C#，更是抢先一步在.NET 3.5 版本时就有了对函数式编程的支持。后来.NET 平台上更是直接引入了函数式编程语言 F#。</p>
<p>函数式编程的兴起并非没有原因。</p>
<ul>
<li><strong>函数式编程语言一般极具表现力</strong>. 相比主流的面向对象语言能以极少的代码完成相同的工作。与代码量的减少相对应的就是维护成本的降低。</li>
<li>相对于命令式编程，<strong>函数式编程语言都是采用声明式编程的方式</strong>，能在更高的抽象级别上编程，代码更易于理解。</li>
<li>**纯函数是没有副作用的，既不会修改全局状态，也不会修改传入的参数。**在进行多线程编程时，就从根本上避免死锁，活锁或者是线程饥饿的问题。</li>
</ul>
<h2 id="函数式编程语言的特征">函数式编程语言的特征</h2>
<h3 id="高阶函数">高阶函数</h3>
<p>在函数式编程语言中，函数终于成为一等公民，可以跟变量一样作为参数传递，同时也可以作为函数返回值返回。这个功能带来的直接好处就是当我们需要传递<strong>行为</strong>的时候，不必在跟之前一样为了传递行为而引入一个对象。例如在 Java 8 之前，当我们想排序一个 List 时：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">	List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> values <span style="color:#f92672">=</span> newArrayList<span style="color:#f92672">(</span>11<span style="color:#f92672">,</span> 2<span style="color:#f92672">,</span> 43<span style="color:#f92672">,</span> 14<span style="color:#f92672">,</span> 5<span style="color:#f92672">,</span> 76<span style="color:#f92672">,</span> 6<span style="color:#f92672">);</span>
	Collections<span style="color:#f92672">.</span><span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>values<span style="color:#f92672">,</span> <span style="color:#66d9ef">new</span> Comparator<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;()</span> <span style="color:#f92672">{</span>
	    <span style="color:#a6e22e">@Override</span>
	    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">compare</span><span style="color:#f92672">(</span>Integer one<span style="color:#f92672">,</span> Integer other<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
	        <span style="color:#66d9ef">return</span> one<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>other<span style="color:#f92672">);</span>
	    <span style="color:#f92672">}</span>
	<span style="color:#f92672">});</span>

</code></pre></div><p>Java 8 引入了 Lambda 之后，我们不必再引入一个对象来封装我们的排序逻辑：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">	Collections<span style="color:#f92672">.</span><span style="color:#a6e22e">sort</span><span style="color:#f92672">(</span>values<span style="color:#f92672">,</span> <span style="color:#f92672">(</span>a<span style="color:#f92672">,</span> b<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">compareTo</span><span style="color:#f92672">(</span>b<span style="color:#f92672">));</span>
</code></pre></div><p>本质上讲，传递进来的还是一个对象，只不过是因为 Functional Interface 的存在，我们可以<strong>假装</strong>传入的是一个函数。这一点在我们使用传入的对象时就更为明显: 我们不得不像使用对象一样通过调用 apply 方法来应用传入的<em>函数</em>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> T <span style="color:#a6e22e">create</span><span style="color:#f92672">(</span>String stringValue<span style="color:#f92672">,</span> Function<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span> T<span style="color:#f92672">&gt;</span> instantiator<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> instantiator<span style="color:#f92672">.</span><span style="color:#a6e22e">apply</span><span style="color:#f92672">(</span>stringValue<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>在纯粹的函数式编程语言中，高阶函数的使用则更为自然， 如在 haskell 中，</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">	add <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> a
	add a b <span style="color:#f92672">=</span> a <span style="color:#f92672">+</span> b

	perform <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> (a <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> a) <span style="color:#f92672">-&gt;</span> a
	perform a b action <span style="color:#f92672">=</span> action a b

	<span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> perform <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">1</span> add
	<span style="color:#f92672">//</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>

</code></pre></div><p>既然函数可以作为参数传递，也可以作为返回值，那么函数之间的<strong>运算</strong>也就不足为奇了。以下是 Haskell 中用来组合（compose）函数的函数(对，这里没有写错，就是通过组合函数来生成更强大函数)。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">	(<span style="color:#f92672">.</span>) <span style="color:#f92672">::</span> (b <span style="color:#f92672">-&gt;</span> c) <span style="color:#f92672">-&gt;</span> (a <span style="color:#f92672">-&gt;</span> b) <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> c
	(<span style="color:#f92672">.</span>) f g x <span style="color:#f92672">=</span> f(g(x))
</code></pre></div><p>利用(.)，我们可以对函数进行组合：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">	plus <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> a
	plus x <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>

	double <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> a
	double x <span style="color:#f92672">=</span> x <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>

	plusThenDouble <span style="color:#f92672">=</span> double<span style="color:#f92672">.</span>plus

	<span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> plusThenDouble <span style="color:#ae81ff">1</span>
	<span style="color:#f92672">//</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
</code></pre></div><h3 id="科里化currying">科里化(Currying)</h3>
<p><a href="https://en.wikipedia.org/wiki/Currying">科里化</a>把一个（接收多个参数的函数）的运算转化为多个（只接收一个参数的函数）的运算。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">	add <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> a
	add a b <span style="color:#f92672">=</span> a <span style="color:#f92672">+</span> b
</code></pre></div><p>函数 add 接收两个参数，返回两者的和。我们可以把函数 add 理解为接收一个参数 a，然后返回一个函数 addA。函数 B 接收另外一个参数 B, 返回值则是 A+B。那么 1+2 的例子就可以如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell">   add1 <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> a
   add1 <span style="color:#f92672">=</span> add <span style="color:#ae81ff">1</span>

   <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> add1 <span style="color:#ae81ff">2</span> <span style="color:#f92672">//</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</code></pre></div><p>上面的例子中 add1 其实就是一个部分应用函数(Partial Applied Function)。</p>
<p>其实这就是函数式编程语言中代码重用的方式。面向对象语言通过继承和组合重用已有逻辑，函数式语言可以通过部分应用函数以及函数组合来实现代码复用。</p>
<p>本篇文章是函数式编程系列之一：</p>
<ol>
<li>函数式编程 101</li>
<li><a href="https://ddou.github.io/posts/functional-programming-concepts-part-two/">函数式编程 101 (续)</a></li>
<li><a href="https://ddou.github.io/posts/functional-programming-in-real-world/">函数式编程初体验 一</a></li>
<li><a href="https://ddou.github.io/posts/functional-programming-in-real-world-2/">函数式编程初体验 二</a></li>
<li><a href="https://ddou.github.io/posts/functional-programming-in-real-world-3/">函数式编程初体验 三</a></li>
</ol>

</article>

<script src="https://utteranc.es/client.js"
        repo="ddou/ddou.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

<style>
    div.utterances {
        max-width: 80%;
        width: 60%;
    }
</style>

<script>
    (function (i, s, o, g, r, a, m) {
    i['GoogleAnalyticsObject'] = r; i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date(); a = s.createElement(o),
        m = s.getElementsByTagName(o)[0]; a.async = 1; a.src = g; m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-40664887-1' , { 'siteSpeedSampleRate': 100 });
    ga('send', 'pageview');
    ga('set', 'anonymizeIp', true);
</script>



</html>
